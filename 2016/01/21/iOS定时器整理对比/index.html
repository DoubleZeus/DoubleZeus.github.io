<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="ZeusZhang"><title>iOS定时器整理对比 · ZeusZhang</title><meta name="description" content="NSTimer什么是NSTimer通过官方文档”A timer provides a way to perform a delayed ation or a periodic action. The timer waits until a certain time interval has elap"><meta name="keywords" content="zeus,zeuszhang,dobulez,iOS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">ZeusZhang</a></h3><div class="description"><p>zeuszhang blog</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>iOS定时器整理对比</a></h3></div><div class="post-content"><h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><h4 id="什么是NSTimer"><a href="#什么是NSTimer" class="headerlink" title="什么是NSTimer"></a>什么是NSTimer</h4><p>通过官方文档”A timer provides a way to perform a delayed ation or a periodic action. The timer waits until a certain time interval has elapsed and then fires, sending a specified message to a specified objec.”翻译过来就是timer就是一个能从现在开始的后面某个时刻或者周期性的执行我们制定的方法对象。</p>
<h4 id="NSTimer和它调用的函数对象"><a href="#NSTimer和它调用的函数对象" class="headerlink" title="NSTimer和它调用的函数对象"></a>NSTimer和它调用的函数对象</h4><p>从前面官方解释可以看出timer会在未来的某个时刻执行一次或者多次执行我们指定的方法，这也就牵扯出一个问题，如何保证timer触发时，我们指定的方法是有效的呢？答案很简单，就是timer对它的target进行retain，我们需要小心对待target的生命周期问题，尤其是重复性的timer。在timer触发我们指定的方法后，我们需要释放timer，这里提供了invalidate方法，否则被retain的方法内对象将一直存在，造成内存泄漏。</p>
<h4 id="NSTimer会准时触发事件吗？"><a href="#NSTimer会准时触发事件吗？" class="headerlink" title="NSTimer会准时触发事件吗？"></a>NSTimer会准时触发事件吗？</h4><p>这个答案是否定的，而且有时候会发现实际触发时间跟你设定的时间会差距挺大的，这要从NSTimer的实现说起。<br>NSTimer不是一个实时系统，所以timer触发的时机会有误差，差距的大小主要跟当前我们程序的执行情况有关系，比如程序是多线程的，而timer只是添加在某一个线程的Runloop的某一种指定的runloopmode中，由于多线程通常都是分时执行，而且每次执行的mode也可能随着时机情况变化而改变，或者在某一个时刻线程有大量复杂的运算。这些都会导致timer的触发时机不够精准。</p>
<h2 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h2><h4 id="什么是CADisplayLink"><a href="#什么是CADisplayLink" class="headerlink" title="什么是CADisplayLink"></a>什么是CADisplayLink</h4><p>CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容绘制到屏幕上的定时器。</p>
<h4 id="CADisplayLink和它调用的函数对象"><a href="#CADisplayLink和它调用的函数对象" class="headerlink" title="CADisplayLink和它调用的函数对象"></a>CADisplayLink和它调用的函数对象</h4><p>我们在应用中创建一个CADisplayLink对象，把它添加到一个RunLoop中，并给他提供一个target和selector在屏幕刷新的时候调用；一旦该对象被以特定模式注册到RunLoop中，每当屏幕刷新时，RunLoop就会主动调用该对象绑定的target上的selector，这时target可以拿到CADisplayLink调用的时间戳，用来准备下一帧的数据。</p>
<h4 id="CADisplayLink的准确性"><a href="#CADisplayLink的准确性" class="headerlink" title="CADisplayLink的准确性"></a>CADisplayLink的准确性</h4><p>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精度比NSTimer要高很多，但是CADisplayLink适用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的适用范围相对广泛。<br><strong>需要注意的是iOS设备的刷新频率是60HZ，也就是每秒60次。那么每一次刷新时间大约16.7毫秒。当我们的<em>frameInterval</em>的值为1的时候我们需要保证CADisplayLink调用的target的函数计算时间不应该大于16.7否则会出现严重的丢帧现象</strong></p>
<h2 id="GCD-Source"><a href="#GCD-Source" class="headerlink" title="GCD Source"></a>GCD Source</h2><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p>为了避免NSTimer可能存在的风险，我们可以选择使用dispatch_after，使用gcd时系统会帮我们处理线程级的逻辑；除此之外，我们也不需要考虑RunLoop的问题，这样调用对象也不会被持有，上述关于内存泄漏也不存在了。当然，需要注意block可能导致的循环引用问题。<br><strong>但是dispatch_after也有一个很严重的问题，那就是一旦执行后就不能撤销了！！！</strong></p>
<h4 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h4><p>这个时候我们就可以用GCD本身的timer功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class="line">dispatch_source_t tiemr = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0,0,queue);</span><br><span class="line">dispatch_source_set_timer(timer,DISPATCH_TIME_NOW,2.0 * NSEC_PER_SEC,0.1 * NSEC_PER_SEC);</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">dispatch_source_set_event_handler(timer,&lt;&#123;</span><br><span class="line">    [weakSelf action];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line">disaptch_source_cancel(timer);</span><br></pre></td></tr></table></figure></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-01-21</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2016/01/21/iOS定时器整理对比/,ZeusZhang,iOS定时器整理对比,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2016/03/03/GCD使用总结/" title="GCD使用总结">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/10/20/WKWebView与js的交互/" title="WKWebView与js交互">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>