<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="ZeusZhang"><title>GCD使用总结 · ZeusZhang</title><meta name="description" content="###什么是GCDGCD全称为Grand Centeral Dispatch，为iOS和OS X的多核硬件上执行提供控制，是意不执行任务的技术之一。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并执行计划任务。由于线程管理是作为系统的一部分来实现的"><meta name="keywords" content="zeus,zeuszhang,dobulez,iOS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">ZeusZhang</a></h3><div class="description"><p>zeuszhang blog</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>GCD使用总结</a></h3></div><div class="post-content"><p>###什么是GCD<br>GCD全称为Grand Centeral Dispatch，为iOS和OS X的多核硬件上执行提供控制，是意不执行任务的技术之一。<br>开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并执行计划任务。由于线程管理是作为系统的一部分来实现的，因此可以统一管理，也可执行任务，这样就比以前的线程更有效率。举个🌰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue,^&#123;</span><br><span class="line">    /*</span><br><span class="line">    * 长时间任务处理</span><br><span class="line">    *</span><br><span class="line">    * 例如数据库访问</span><br><span class="line">    */</span><br><span class="line">    /*</span><br><span class="line">    * 长时间处理结束，主线程中使用结果</span><br><span class="line">    */</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码就是在后台执行线程中执行长时间处理，处理结束时，主线程使用该处理结果的源代码。</p>
<p>###Dispatch Queue的种类<br>Dispatch queue的种类有两种：一种是等待执行中处理结束的<strong>Serial Dispatch Queue（串行队列）</strong>，另一种是不等待执行中处理的<strong>Concurrent Dispatch Queue（并行队列）</strong>。<br>虽然有了Queue的种类，那么如何才能得到Dispatch queue呢？</p>
<p>####dispatch_queue_create<br>第一中方法是通过GCD的Api生成Dispatch Queue<br><figure class="highlight plain"><figcaption><span>myQueue </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">Serial Dispatch queue可以在创建时用NULL标识；多个线程更新相同资源导致数据竞争时建议使用Serial Dispatch Queue</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t myQueue = dispatch_queue_create(“com.zeuszhang.gcd.myQueue”,DISPATCH_QUEUE_CONCURRENT);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">####Main Dispatch Queue/Global Dispatch Queue</span><br><span class="line">第二种方法是获取系统提供的Dispatch Queue</span><br><span class="line"></span><br><span class="line">Main Dispatch Queue主线程只有一个自然是Serial dispatch queue</span><br><span class="line">dispatch_queue_t myQueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<p>Global Dispatch Queue是所有程序都能够使用Concurrent dispatch queue。另外Global Dispatch queue有4个执行优先级<br>1.High Priority<br>2.Default Priority<br>3.Low Priority<br>4.Background Priority<br>dispatch_queue_t myQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);//第一个参数表示优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_set_target_queue</span><br><span class="line">dispatch_queue_create函数生成的Dispatch Queue不管是Serial dispatch queue还是Concurrent dispatch queue，都使用默认优先级（default）Global Dispatch queue相同执行优先级的线程。而变更生成的Dispatch queue的优先级需要用到dispatch_set_target_queue函数。🌰如下</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t myQueue = dispatch_queue_create(“com.zeuszhang.gcd.myQueue”,NULL);<br>dispatch_queue_t globalQueueBackground = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_BACKROUND,0);<br>dispatch_set_target_queue(myQueue,globalQueueBackground);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定变更优先级的Dispatch Queue为dispatch_set_target_queue函数第一个参数，指定要使用的执行优先级的Global dispatch queue为第二个参数；**ps（第一个参数不可指定为系统提供的Main Dispatch Queue或者Global Dispatch Queue）**</span><br><span class="line"></span><br><span class="line">###dispatch_after</span><br><span class="line">GCD延时函数</span><br></pre></td></tr></table></figure></p>
<p>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);<br>dispatch_after(time,dispatch_get_main_queue(),^{<br>    NSLog(@”waited at least three seconds”);<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是dispatch_after函数并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。</span><br><span class="line"></span><br><span class="line">###Dispatch Group</span><br><span class="line">在Dispatch Queue中处理多个全部结束后想执行的操作，就可以使用Dispatch Group来使代码更简单</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_group_t group = dispatch_group_create();<br>dispatch_group_async(group,queue,^{NSLog(@”b1k0”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k1”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k2”);});<br>dispatch_group_notify(group,dispatch_get_main_queue(),^{NSLog(@”dine”);});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在dispatch_group_notify函数中不管制定什么样的Dispatch Queue，属于Dispatch Group的全部处理再追加制定的Block时都已经执行结束。另外，在Dispatch Group中也可以使用dispatch_group_wait函数仅等待全部处理执行结束。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_group_t group = dispatch_group_create();<br>dispatch_group_async(group,queue,^{NSLog(@”b1k0”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k1”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k2”);});<br>dispatch_group_wait(group,DISPATCH_TIME_FORVER);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait函数的第二个参数指定为等待时间属于dispatch_time_t类型的值</span><br></pre></td></tr></table></figure></p>
<p>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);<br>long result - dispatch_group_wait(group,time);<br>if (result == 0) {<br>    //group的处理全部结束<br>} else {<br>    //group处理中<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果dispatch_group_wait的返回值不为0，就意味着虽然过了指定的时间，但group中还有处理没有结束；若为0，则全部处理执行完毕。当等待时间为DISPATCH_TIME_FOREVER,由group的处理必定全部结束。</span><br><span class="line"></span><br><span class="line">###dispatch_barrier_async</span><br><span class="line">在访问数据库时，前面说用Serial dispatch queue可以避免数据竞争。写入不可以与读取处理并行操作，但是如果是读写与读写是可以并行的。</span><br><span class="line">也就是为了高效访问，读取处理追加到Concurrent dispatch queue中，写入处理在任一个读取处理没有执行的状态下追加到Serial dispatch queue中即可。虽然用group月dispatch_set_target_queue也可以处理，但代码逻辑复杂，这里提供一个简单方法**dispatch_barrier_async**</span><br><span class="line">🌰：</span><br></pre></td></tr></table></figure></p>
<p>首先生成一个Concurrent dispatch queue在queue中追加读取处理<br>dispatch_queue_t queue = dispatch_queue_create(“com.zueszhang.gcd.forBarrier”,DISPATCH_QUEUE_CONCURRENT);<br>dispatch_async(queue,b1k0_fro_reading);<br>dispatch_async(queue,b1k1_fro_reading);<br>dispatch_async(queue,b1k2_fro_reading);<br>dispatch_async(queue,b1k3_fro_reading);<br>dispatch_barrier_async(b1k_for_writing);<br>dispatch_async(queue,b1k4_fro_reading);<br>dispatch_async(queue,b1k5_fro_reading);<br>dispatch_async(queue,b1k6_fro_reading);<br>dispatch_async(queue,b1k7_fro_reading);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_sync</span><br><span class="line">dispatch_sync就是将指定的block***同步***的追加到指定的Dispatch Queue中，再追加Block结束之前，dispatch_sync函数会一直等待。</span><br><span class="line"></span><br><span class="line">###dispatch_apply</span><br><span class="line">dispatch_apply函数是将dispatch_sync和Dispatch Group关联的api。该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中，并等待全部处理结束</span><br><span class="line">🌰</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_apply(10,queue,^(size_t index) {<br>    NSLog(@”%zu”,index)<br>})<br>NSLog(@”Done”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为在Global Dispatch queue中处理所以线程，所以各个操作时间不定。但是Done肯定是在最后被输出。</span><br><span class="line">第一个参数为重复次数，第二个参数是追加对象的Dispatch Queue，第三个参数为追加的block处理。</span><br><span class="line">常用作与对数组类对象的所有元素执行处理时，可以替代for循环的效果。</span><br><span class="line">另外，由于dispatch_apply函数也与dispatch_sync函数相同，会等待处理执行结束，因此推荐在dispatch_async函数中非同步的执行dispatch_apply</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>//在global dipsatch queue中非同步执行<br>dispatch_async(queue,^{<br>    //等待dispatch_apply函数中全部处理结束<br>    dispatch_apply([array count],queue,^(size_t index){<br>        //并列处理包含在array中的全部对象<br>        NSLog(@”%zu:%@”,index,[array objectAtIndex:index]);<br>    });<br>    //等待完毕后在main中执行处理<br>    dispatch_async(dispatch_get_main_queue(),^{<br>        NSLog(@”Done”);<br>    });<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_suspend / dispatch_resume</span><br><span class="line">当追加大量处理到Disaptch Queue时，再追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被block截获时，一些处理会对这个结果造成影响。这种情况下，只要挂起Dispatch Queue即可，当可执行时再恢复。</span><br><span class="line"></span><br><span class="line">###Dispatch Semaphore</span><br><span class="line">当并行执行的处理更新数据时，会产生数据竞争的可能，有时还会导致程序异常。虽然通过Serial Dispatch Queue和dispatch_barrier_async函数可以避免这类问题，但是有必要更细力度的控制它。</span><br><span class="line">🌰：不考虑排序，将所有数据追加到NSMutableArray中。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>NSMutableArray *array = [[NSMutableArray alloc] init];<br>for (int i = 0; i &lt; 10000; i++) {<br>    dispatch_async(queue,^{<br>        [array addObject:[NSNumber numberWithInt:i]];<br>    });<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此时，使用global更新NSMutableArray对象，所以执行后由内存错误导致程序异常结束概率很高。此时应该使用Dispatch Semaphore。</span><br><span class="line">Dispatch Semaphore是持有计数的信号，该计数是多线程编程中的计数类型信号。在Dispatch Semaphore中，计数为0时等待，计数为1或大于1时，减去1而不等待。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数表示计数的初始值。从函数创建名称中create可以看出，该函数与Dispatch Queue和Dispatch Group一样，必须通过dispatch_release函数释放。</span><br><span class="line">dispatch_semaphore_wait函数等待Dispatch Semaphore的计数值达到大于或等于1。当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从dispatch_semaphore_wait函数返回。第二个参数与dispatch_group_wait函数等相同，由dispatch_time_t类型值指定等待时间。</span><br><span class="line">🌰：</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);<br>NSMutableArray *array = [[NSMutableArray alloc] init];<br>for (int i = 0; i &lt; 10000; ++i) {<br>    dispatch_async(queue,^{<br>        dispatch_semaphore_wait(semaphore,DISPATCH_TIME_FOREVER);<br>        [array addObject:[NSNumber numberWithInt:i]];<br>        dispatch_semaphore_signal(semaphore);<br>    })<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_once</span><br><span class="line">这个应该是最常用的GCD api了。该函数是保证在应用程序中执行一次指定处理的Api。</span><br><span class="line">iOS单例模式：</span><br></pre></td></tr></table></figure></p>
<p>static id manager = nil;<br>-(id)defaultManager {<br>    static dispatch_once_t once;<br>    dispatch_once(&amp;once,^{<br>        manager = [[self alloc] init];<br>    });<br>    return manager;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###Dispatch I/O</span><br><span class="line">读取较大文件时，如果将文件分成合适的大小并使用Global Dispatch Queue并列读取的话，应该会比一般的读取速度快不少。现今的输入/输出硬件已经可以做到一次使用多个线程更快的并列读取了。能实现这一功能的就是Dispatch I/O和Dispatch Data通过Dispatch I/O读写文件时，使用Global Dispatch Queue将1个文件按某个大小read/write</span><br></pre></td></tr></table></figure></p>
<p>disaptch_async(queue,^{/<em>读取  0 ~ 800字节</em>/});<br>disaptch_async(queue,^{/<em>读取  801 ~ 1600字节</em>/});<br>disaptch_async(queue,^{/<em>读取  1601 ~ 2400字节</em>/});<br>disaptch_async(queue,^{/<em>读取  2401 ~ end</em>/});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像上面这样，将文件分割为一块一块的进行读取处理。分割读取的数据通过使用Dispatch Data可进行更为简单的进行结合和分割</span><br><span class="line">🌰：</span><br></pre></td></tr></table></figure></p>
<p>pipe_q = dispatch_queue_create(“PipeQ”,NULL);<br>pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM,fd,pipe_q,^(int err) {<br>    close(fd);<br>})</p>
<p><em>out_fd = fdpair[1];<br>dispatch_io_set_low_water(pipe_channel,SIZE_MAX);<br>dispatch_id_read(pipe_channel, 0, SIZE_MAX, pipe_q,^(bool done,     dispatch_data_t pipedata, int err) {<br>    if (err == 0) {<br>        size_t len = dispatch_data_get_size(pipedata);<br>        if (len &gt; 0) {<br>            const char </em>bytes = NULL;<br>            char <em>encoded;<br>            dispatch_data_t md = dispatch_data_create_map(pipedata,(const void <strong>)&amp;bytes, &amp;len);<br>            encoded -asl_core_encode_buffer(bytes,len);<br>            asl_set((aslmsg)merged_msg,ASL_KEY_AUX_DATA,encoded);<br>            free(encoded);<br>            _asl_send_message(NULL,merged_msg,-1,NULL);<br>            asl_msg_release(merged_msg);<br>            dispatch_release(md);<br>        }<br>    }<br>    if (done) {<br>        dispatch_semphore_signal(sem);<br>        dispatch_release(pipe_channel);<br>        dispatch_release(pipe_q);<br>    }<br>});<br><code>`</code>
</strong></em>同样使用”create”生成的对象最后都要释放。***</p>
<p>###Disaptch Source<br>GCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。他是BSD系内核惯有功能kqueue的包装。<br>kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术(ps不重要)。它的CPU负荷非常小，尽量不占用资源。<br>Dispatch Source种类</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">种类</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:center">变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:center">变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:center">端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:center">端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:center">检测到与进程有关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:center">可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:center">接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:center">定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:center">文件系统变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:center">可写入映像</td>
</tr>
</tbody>
</table>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-03-03</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2016/03/03/GCD使用总结/,ZeusZhang,GCD使用总结,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2016/04/08/Cocoapods静态库整理/" title="Cocoapods静态库整理">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/01/21/iOS定时器整理对比/" title="iOS定时器整理对比">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>