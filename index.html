<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>ZeusZhang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="zeuszhang blog">
<meta name="keywords" content="zeus,zeuszhang,dobulez,iOS">
<meta property="og:type" content="website">
<meta property="og:title" content="ZeusZhang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ZeusZhang">
<meta property="og:description" content="zeuszhang blog">
<meta property="og:locale" content="Objective-C,Swift,JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZeusZhang">
<meta name="twitter:description" content="zeuszhang blog">
  
    <link rel="alternative" href="/atom.xml" title="ZeusZhang" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">ZeusZhang</a></h1>
        </hgroup>
        
        <p class="header-subtitle">zeuszhang blog</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/开发工具/">玩转开发工具</a></li>
                        
                            <li><a  href="/categories/digital">玩转数码</a></li>
                        
                            <li><a  href="/categories/algorithm">算法学习</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/cocoapods/" style="font-size: 10px;">cocoapods</a> <a href="/tags/gcd/" style="font-size: 10px;">gcd</a> <a href="/tags/timer/" style="font-size: 10px;">timer</a> <a href="/tags/二进制-cocoapods/" style="font-size: 10px;">二进制 cocoapods</a> <a href="/tags/架构设计/" style="font-size: 10px;">架构设计</a> <a href="/tags/架构设计-block/" style="font-size: 10px;">架构设计 block</a> <a href="/tags/跨平台-flutter/" style="font-size: 10px;">跨平台 flutter</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱动漫,爱游戏,爱编程,爱运动,爱的太多了!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">ZeusZhang</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">ZeusZhang</a></h1>
            </hgroup>
            
            <p class="header-subtitle">zeuszhang blog</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/开发工具/">玩转开发工具</a></li>
                
                    <li><a href="/categories/digital">玩转数码</a></li>
                
                    <li><a href="/categories/algorithm">算法学习</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Flutter学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2020/04/12/Flutter学习/" class="article-date">
      <time datetime="2020-04-12T11:27:56.244Z" itemprop="datePublished">2020-04-12</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2020/04/12/Flutter学习/">flutter学习</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="Flutter原理"><a href="#Flutter原理" class="headerlink" title="Flutter原理"></a>Flutter原理</h3><p>Flutter是Google推出并开源的移动应用开发框架，主打跨平台、高性能。开发者通过Dart语言开发App，一套代码同时运行在iOS和Android平台。Flutter提供了丰富的组件和接口，开发者也可以很方便的为Flutter添加Native扩展。同时还使用了Native引擎渲染师徒，这也使得用户体验更好。</p>
<h3 id="绘图原理"><a href="#绘图原理" class="headerlink" title="绘图原理"></a>绘图原理</h3><p>我们都知道显示器以固定的频率刷新，当一帧图像绘制完毕后准备绘制下一帧时，显示器会发出一个垂直同步信号（VSync），所以60Hz的屏幕会一秒内发出60次这样的信号。并且，计算机的CPU、GPU和显示器以一种特定的方式协作：CPU将计算好的内容提交给GPU，GPU渲染后放入帧缓冲区，然后视频控制器按照VSync信号从帧缓冲区取帧数据传递给显示器显示。<br>Android、iOS的App在显示UI时是如此，Flutter也不例外的遵循了这种模式。所以从这看出Flutter和RN的本质区别：RN只是扩展调用OEM组件，而Flutter是自己渲染。下图是Google提供的渲染过程<br><img src="https://pic3.zhimg.com/80/v2-6206a81c7e819ea20def8553c82f8046_1440w.jpg" alt="avatar"><br>从图中可以看出：Flutter指关心想GPU提供视图数据，GPU的VSync信号同步到UI线程，UI线程使用Dart来构建抽象的视图结构，这份数据结构在GPU线程进行图层合成，视图诗句提供给Skia引擎渲染为GPU数据，这些数据通过OpenGL或者Vulkan提供给GPU。<br>所以Flutter并不关心显示器、视频控制器以及GPU具体工作，它只关心GPU发出的VSync信号，尽可能快的在两个VSync信号之间计算并合成视图数据，并且把数据提供给GPU。</p>
<h3 id="Flutter设计"><a href="#Flutter设计" class="headerlink" title="Flutter设计"></a>Flutter设计</h3><p><img src="https://pic2.zhimg.com/80/v2-09427bc58bb35004bc812874731509cd_1440w.jpg" alt="avatar"><br>Flutter Framework：这是一个纯Dart实现的SDK。它实现了一套基础库，用于处理动画、绘图和手势。并且基于绘图封装了一套UI组件库。<br>FLutter Engine：这是一个纯C++实现的SDK，其中包括了Skia引擎（2D绘图引擎，Android自带Skia引擎，所以Flutter Android SDK比iOS SDK小很多）、Dart运行时、文字排版引擎等</p>
<h3 id="Flutter应用的运行"><a href="#Flutter应用的运行" class="headerlink" title="Flutter应用的运行"></a>Flutter应用的运行</h3><p><img src="https://pic3.zhimg.com/80/v2-75ae79d5702e51a6e4e2be0a36e7305e_1440w.jpg" alt="avatar"><br>在应用的VC初始化后，会实例化一个Flutter project的抽象。project会初始化一个platform View的抽象实例，这个抽象实例会负责创建Flutter的运行时（engine)<br>当VC将显示时，调用project查找和组合Flutter的应用资源bundle，并把资源提供给engine。<br>engine在真正需要执行资源bundle时才会创建Dart执行环境（懒加载）Dart Controller，<br>然后设置视图窗口的一些属性等。<br>然后engine中的Dart Controller会加载Dart代码并执行，执行的过程中会调用Native binding实现向GPU提供数据</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跨平台-flutter/">跨平台 flutter</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-循环引用解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/08/21/循环引用解决方案/" class="article-date">
      <time datetime="2019-08-21T02:46:10.000Z" itemprop="datePublished">2019-08-21</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/08/21/循环引用解决方案/">循环引用解决方案</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>return cycle在iOS开发中经常遇到的⚠️；当两个对象相互强引用对方时，无论哪一方调用release方法时，双方的引用计数都还大于等于1，所以不会调用dealloc方法，导致释放代码内存的方法没有执行，形成循环等待，即循环引用。<br>解决方案就是打破任一方的强引用：</p>
<ol>
<li>使用较多的是<strong>weak；声明一个弱引用类型的对象，解除循环引用，</strong>weak跟weak类似，当对象被系统回收时，内存地址会被指向nil，对nil的任何操作都被视为无效</li>
<li>在较老的iOS版本中，我们也可以使用__unsafe_unretained标识符解除循环引用，但存在一定的不安全性</li>
<li>@weakify和@strongify,这个是github上的开源库libextobjc，在EXTScope.h中有关于weak和storng的宏定义</li>
<li>还有一种方法就是手动将某一对象置为nil，但是下次在使用之前必须重新赋值否则会报错<br>在这里个人比较推荐第3种方案，前面方案都有其局限性和不确定性。</li>
</ol>
<h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>Blocks是C语言的扩充功能。用一句话表示就是：带有自动变量（局部变量）的匿名函数。<br>而Blocks中导致错误的最多的问题就是循环引用导致的内存泄漏等等问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedof void(^CallBack)(void);</span><br><span class="line">#class</span><br><span class="line">@property (nonatomic, copy) CallBack callBack;     </span><br><span class="line"></span><br><span class="line">self.callBack = ^&#123;</span><br><span class="line">    self.view.backgroundColor = [UIColor redColor];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.callBack();</span><br></pre></td></tr></table></figure></p>
<p>上面这种使用方法就是个典型的循环引用，当前VC执行pop时由于这个循环引用导致内存并不会被释放而产生内存泄漏；而根据之前提到的解决方案就是</p>
<ol>
<li>__weak typeof(self) weakSelf = self;</li>
<li>__unsafe_unretained typeof(self) weakSelf = self;</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.callBack = ^&#123;</span><br><span class="line">    @strongify(self);</span><br><span class="line">    self....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>self.callBack = nil;</p>
</li>
</ol>
<p>第3中方案基本完美解决了循环引用问题，但是作为一个更有追求开发者，当你在向外提供API时，所有组件的使用方都不需要考虑循环引用才是最优的API设计，在这里我们修改一下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedof void(^CallBack)(id target);</span><br><span class="line">#class</span><br><span class="line">@property (nonatomic, copy) CallBack callBack;     </span><br><span class="line"></span><br><span class="line">self.callBack = ^(id target)&#123;</span><br><span class="line">    if ([target isKindOfClass:[Class class]]) &#123;</span><br><span class="line">        ((Class *)target).view.backgroundColor = [UIColor redColor];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.callBack(self);</span><br></pre></td></tr></table></figure></p>
<p>我们将block中要用到的外部对象用参数的形式传递到block中，这样就不会造成循环引用了。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构设计-block/">架构设计 block</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-iOS二进制与cocoapods插件开发" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/08/14/iOS二进制与cocoapods插件开发/" class="article-date">
      <time datetime="2019-08-14T08:58:31.000Z" itemprop="datePublished">2019-08-14</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/08/14/iOS二进制与cocoapods插件开发/">iOS二进制与cocoapods插件开发</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>随着项目开发越来越臃肿，二进制化已经无可避免，它可以极大的加速项目编译过程，缩减编译时间，也可以在我们对外部开发提供SDK时，保护我们的源文件内容。</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>基于组件化开发或者SDK分发，我们可以把组件做成静态库。iOS中静态库形式是.a与.framework；动态库的形式是.dylib和.framework。关于.framework，iOS不允许我们建立自己的动态.framework，但系统提供的.framework是动态库.</p>
<h4 id="静态库与动态库的区别"><a href="#静态库与动态库的区别" class="headerlink" title="静态库与动态库的区别"></a>静态库与动态库的区别</h4><ol>
<li>静态库：链接时完整的拷贝至可执行文件中，被多次使用就会有多份冗余拷贝。</li>
<li>动态库：链接时不复制，程序运行时由系统动态加载到内存中，供程序调用，系统只加载一次，多个程序公用，节省内存。</li>
</ol>
<h4 id="a与-framework的区别"><a href="#a与-framework的区别" class="headerlink" title=".a与.framework的区别"></a>.a与.framework的区别</h4><ol>
<li>.a是纯二进制文件，.framework中除了有二进制文件还有资源文件</li>
<li>.a文件不能直接使用，需要配合.h文件配合；.framework可以直接使用，因为他本身包含了.h和资源</li>
<li>.a + .h + source = .framework<br><strong><em>建议使用.framework</em></strong></li>
</ol>
<h3 id="打包二进制文件"><a href="#打包二进制文件" class="headerlink" title="打包二进制文件"></a>打包二进制文件</h3><p>制作二进制包主要有两种方法</p>
<ol>
<li>通过xcodebuild创建对应的二进制工程，然后分别生成模拟器下与真机环境下的二进制文件，最后将两个二进制文件合并成最终需要的文件，过程不再赘述。</li>
<li>另外就是通过cocoapods-packager生成二进制文件</li>
</ol>
<h4 id="cocoapods-packager"><a href="#cocoapods-packager" class="headerlink" title="cocoapods-packager"></a>cocoapods-packager</h4><p><a href="https://github.com/CocoaPods/cocoapods-packager" target="_blank" rel="noopener">cocoapods-packager</a>是cocoapods的自动化打包插件，可以用来打包生成动态库或者静态库。<br>部分参数配置如下:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td> –force</td>
<td style="text-align:center">强制覆盖之前生成的库</td>
</tr>
<tr>
<td> –embedded</td>
<td style="text-align:center">生成静态.framework</td>
</tr>
<tr>
<td> –library</td>
<td style="text-align:center">生成静态.a</td>
</tr>
<tr>
<td> –dynamic</td>
<td style="text-align:center">生成动态.framework</td>
</tr>
<tr>
<td> –bundle-identifier</td>
<td style="text-align:center">动态.framework需要签名所以要bundleID </td>
</tr>
<tr>
<td> –configuration</td>
<td style="text-align:center">表示生成的库的状态默认是release。–configuration=Debug </td>
</tr>
<tr>
<td> –no-mangle</td>
<td style="text-align:center">表示不使用name mangling技术，pod package默认使用这个技术。</td>
</tr>
</tbody>
</table>
<p><strong><em>如果你的库有其他的依赖就必须要使用name mangling技术，不然打二进制包会报错。</em></strong></p>
<p>相应的打包步骤如下</p>
<ol>
<li>代码库打tag</li>
<li>提交源码到源码repo仓库</li>
<li>执行pod packager命令，将打包成功的framework存放到指定位置</li>
<li>重打tag</li>
<li>提交framework到二进制repo仓库</li>
</ol>
<p>这里能看到就算你准备好了二进制包，但是你还是需要提交源码文件的；因为团队本身开发时迭代升级过程，肯定需要源码调试等等问题，所以我们要达到源码和二进制随意切换的目标，所以需要两套repo存放相同pod的相同tag的不同状态。也可以看出来上面的操作非常繁琐，建议结合gitlab的CI去操作。</p>
<h4 id="cocopods-plugins"><a href="#cocopods-plugins" class="headerlink" title="cocopods plugins"></a>cocopods plugins</h4><p>cocoapods-plugins是一个Ruby gem,当我们为cocoapods开发插件时，需要安装这个gem。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install cocoapods-plugins</span><br></pre></td></tr></table></figure></p>
<p>在这里我们为上面的3、5的步骤提供插件开发实现，插件开发主要作用在于二进制与源码切换；<br>比如我们需要指定某几个pod为源码，或者全部使用源码等等具体实现时，可以再Podfile中修改指定的标志用以达到随意切换的目的，方便开发过程中的调试，加快编译速度。<br>二进制化辅助插件<a href="https://github.com/tripleCC/cocoapods-bin" target="_blank" rel="noopener">cocoapods-bin</a>具体实现可以看看这个。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二进制-cocoapods/">二进制 cocoapods</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-iOS知识梳理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/04/20/iOS知识梳理/" class="article-date">
      <time datetime="2019-04-19T16:00:00.000Z" itemprop="datePublished">2019-04-20</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2019/04/20/iOS知识梳理/">iOS知识梳理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><h5 id="引用计数的思考方"><a href="#引用计数的思考方" class="headerlink" title="引用计数的思考方"></a>引用计数的思考方</h5><ol>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要自己持有的对象时释放</li>
<li>非自己持有的对象无法释放<br>| 对象操作 | OC方法 |<br>| – | :–: |<br>| 生成并持有对象 | alloc/new/copy/mutableCopy… |<br>| 持有对象 | retain |<br>| 释放对象 | release |<br>| 废弃对象 | dealloc |<br>以上述方法开头的方法名拥有相似的对象操作含义</li>
</ol>
<h5 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h5><p>当我们要使用某个方法生成一个对象返回给调用者时，该怎么处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id)allocObject &#123;</span><br><span class="line">    id obj = [NSObject new];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想上个例子中展示，生成obj的时候使用new就是被本身持有的，但是当大括号结束之后这个obj的生命周期就被释放掉了，所以这中间少了重要的一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj autorelease];//取得对象存在，但本身不持有</span><br></pre></td></tr></table></figure></p>
<p>这个时候这个obj对象不会立即释放，而是被注册到autoreleasePool中，当pool结束时自动调用release方法释放对象。<br><strong><em>autorelease的具体使用方法如下</em></strong></p>
<ol>
<li>生成并持有NSAutoreleasePool对象</li>
<li>调用已分配对象的autorelease实例方法</li>
<li>废弃NSAutoreleasePool对象</li>
</ol>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><h5 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h5><ol>
<li>__strong 修饰符:表示对对象的强引用，id类型和对象类型所有权修饰符默认,所以声明时不需要加</li>
<li><strong>weak修饰符：\</strong>\strong无法解决对象之间相互引用导致的循环引用问题，使用weak修饰符打破循环</li>
<li>__unsafe_unretained修饰符</li>
<li>__autoreleasing修饰符：该修饰符一般不显示的出现在代码中，会通过@autoreleasepool的方式隐式的出现</li>
</ol>
<h5 id="内存管理规则总结"><a href="#内存管理规则总结" class="headerlink" title="内存管理规则总结"></a>内存管理规则总结</h5><ol>
<li>不能显示的调用dealloc方法</li>
<li>使用@autorelreasepool块替代NSAutoreleasePool</li>
<li>不能使用区域（NSZone)</li>
<li>对象型变量不能为C语言结构体类型</li>
<li>显示转换id和void*（__bridge转换）</li>
</ol>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><table>
<thead>
<tr>
<th>属性声明</th>
<th style="text-align:center">所有权修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td style="text-align:center">__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td style="text-align:center">__strong</td>
</tr>
<tr>
<td>retain</td>
<td style="text-align:center">__strong</td>
</tr>
<tr>
<td>strong</td>
<td style="text-align:center">__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td style="text-align:center">unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td style="text-align:center">__weak</td>
</tr>
</tbody>
</table>
<h4 id="ARC实现"><a href="#ARC实现" class="headerlink" title="ARC实现"></a>ARC实现</h4><h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h5><p>使用__strong修饰符需要注意一个点，就是当持有一个不是自己生成的对象，并将该对象作为返回值时，编译器会转化出一个方法<strong><em>objc_autoreleaseReturnValue(obj)</em></strong>这个方法的作用与objc_autorelease很相似，但又有点不一样，它会检查使用该函数的调用方的执行命令列表，如果方法或函数中再调用该方法后紧接着调用<strong><em>objc_retainAutoreleaseReturnValue</em></strong>方法，那就不会将obj注册到autoreleasepool中，而是直接返回给函数的调用方。<br><strong><em>可以不降obj注册到autoreleasepool中，而是直接传递，这一过程达到最优化（objc4的493.9版本中，只能在OS X 64位环境下）</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">    objc_msgSend(obj, @selector(init));</span><br><span class="line">    return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h5><ol>
<li>若有__weak修饰符修饰的变量所引用的对象被废弃，则将nil赋值给该变量</li>
<li>使用__weak修饰符的变量，即是使用注册到autoreleasepool中的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 = obj;</span><br><span class="line">&#125;</span><br><span class="line">编译器转换</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1,obj);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>__weak修饰的对象被释放时的流程</p>
<ol>
<li>objc_release </li>
<li>因为引用计数为0所以执行dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating<br>第6步函数动作可以如下解析</li>
<li>从weak表中获取废弃对象的地址为键值得记录</li>
<li>将包含在记录中的所有附在__weak修饰符变量的地址，赋值为nil</li>
<li>从weak表中删除该记录</li>
<li><p>从引用计数表中删除废弃对象的地址为键值得记录<br>使用附有__weak修饰符变量的情形下，怎加了对objc_loadWeakRetained函数和objc_autorelease函数的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1,obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;,tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>objc_loadWeakRetained函数取出附有__weak修饰符变量所引用的对象并retain</p>
</li>
<li>objc_autorelease函数将对象注册到autoreleasepool中</li>
</ol>
<p><strong><em>ps（当allowsWeakReference/retainWeakReference实例方法返回NO的时候，不能使用__weak修饰符,会导致程序crash）</em></strong></p>
<h5 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h5><p>这里需要关注的就是前面提到的成对出现的函数，不注册到autoreleasepool最优内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br></pre></td></tr></table></figure></p>
<h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>Blocks就是带有自动变量的匿名函数。</p>
<h4 id="Blocks结构体"><a href="#Blocks结构体" class="headerlink" title="Blocks结构体"></a>Blocks结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123; //命名规则为：main函数中的第几个block，此处为第一个</span><br><span class="line">    struct __block_impl impl; </span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;//block类型指针</span><br><span class="line">    int Flags;//标志位</span><br><span class="line">    int Reserved;//保留字段</span><br><span class="line">    void *FuncPtr;//函数指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    unsigned long reserved;//保留字段</span><br><span class="line">    unsigned long Block_size;//大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">看看初始化这些结构体的构造函数</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = des;</span><br><span class="line">&#125;</span><br><span class="line">构造函数调用如下</span><br><span class="line">void (*blk)(void) = (void (*)(void))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">去掉转换部分简写如下</span><br><span class="line">struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">struct __main_block_impl_0 *blk = &amp;temp;</span><br><span class="line">第一个参数为Block语法转换的C语言函数指针。第二个参数是作为静态全局变量初始化的__main_block_desc_0结构体实例指针</span><br><span class="line">static struct __main_block_desc_0 __main_block_desc_0_DATA = &#123;</span><br><span class="line">    0,</span><br><span class="line">    sizeof(struct __main_block_impl_0)</span><br><span class="line">&#125;;</span><br><span class="line">这个时候展开_block_impl结构体会被如下初始化</span><br><span class="line">isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">Flags = 0;</span><br><span class="line">Reserved = 0;</span><br><span class="line">FuncPtr = __main_block_func_0;</span><br><span class="line">Desc = &amp;__main_block_desc_0_DATA;</span><br><span class="line"></span><br><span class="line">最后再使用该block时 blk() </span><br><span class="line">((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)blk);</span><br><span class="line">转换如下</span><br><span class="line">（*blk-&gt;impl.FuncPtr)(blk);</span><br></pre></td></tr></table></figure>
<h4 id="截获自动变量"><a href="#截获自动变量" class="headerlink" title="截获自动变量"></a>截获自动变量</h4><p>在block中使用外部变量时，如果在内部对这个外部变量进行赋值，该源代码会产生编译错误。若想在block语法中赋值给block语法外声明的自动变量，需要在该变量上附加__block说明符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int val = 0;</span><br><span class="line">void (^blk)(void) = ^&#123;val = 1;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>上述代码会出现编译错误，但是如果是使用OC对象则没有问题，当然对OC对象直接赋值也是会直接导致编译错误</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id array = [NSMutableArray alloc] init]];</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    id obj = [NSObject alloc] init]];</span><br><span class="line">   [array addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>还有一个需要注意的点是在block中使用截获的C语言数组也是会出现编译错误，因为截获自动变量的方法并没有实现对C语言数组的截获，这个时候需要使用指针解决问题</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char text[] = &quot;hello&quot;; //编译出错 -&gt; const char *text = &quot;hello&quot;;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    printf(&quot;%c\n&quot;,text[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当给外部变量附加了__block说明符，那么源码转换代码会急剧增加，会将外部变量转换为一个结构体实例,该结构体声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_val_0&#123;</span><br><span class="line">    void *__isa;</span><br><span class="line">    __Block_byref_val_0 *__forwarding;</span><br><span class="line">    int __flags;</span><br><span class="line">    int __size;</span><br><span class="line">    int val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我们要重点了解一下这个forwarding成员变量，<strong>Block_byref_val_0结构体实例成员变量 </strong>forwarding持有执行该实例自身的指针，val-&gt; __forwarding -&gt; val</p>
<h4 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h4><table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">实质</th>
</tr>
</thead>
<tbody>
<tr>
<td>Block</td>
<td style="text-align:center">栈上Block的结构体实例</td>
</tr>
<tr>
<td>__block变量</td>
<td style="text-align:center">栈上 __block变量的结构体实例</td>
</tr>
</tbody>
</table>
<p>由于Block也是Objective-C对象，将Block当做OC对象来看时，该Block的类为_NSConcereStackBlock，相似的如</p>
<ol>
<li>_NSConcreteStackBlock  //栈上的block，存储在栈上</li>
<li>_NSConcreteGlobalBlock //全局的block，存储在数据区域.data区中</li>
<li>_NSConcreteMallocBlock //堆上的block，由malloc函数分配的堆中</li>
</ol>
<p>在记叙全局变量的地方使用block语法生成的是Global block；还有一种情况下将block用结构体实例设置在程序的数据区域，那就是在函数内使用Block语法，但是只要Block不截获自动变量。<br>除上述之外的Block语法生成的Block都是设置在栈上的，那么什么时候block会设置在堆上？</p>
<p>配置在全局变量上的Block，从变量作用域外也可以通过指针安全的使用，但设置在栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，由于<strong>block变量也配置在栈上，同样地，如果其所属变量作用域结束，则该 </strong>block变量也会被废弃。<br>Blocks提供了将Block和<strong>block变量从栈上复制到堆上的方法来解决这个问题，将配置在栈上的block赋值到堆上，这样即使block语法记叙的变量作用域结束，堆上的block还可以继续存在。<br>复制到堆上的Block将_NSConcreteMallocBlock类对象写入Block结构体的isa指针，而</strong>block变量用结构体成员变量 <strong>forwarding可以实现无论 </strong>block变量时配置在栈上或者堆上都能正确的访问 __block变量。何时copy是在ARC情况下由编译器自行判断，但是当编译器无法判断时了？<br><strong><em>向方法或函数的参数中传递Block时</em></strong><br>这个时候就需要我们手动的去对block进行copy操作，例如像NSArray中的initWithObjects实例方法上传递block。不管是什么类型的block，复制之后都不会引起任何问题，所以在不确定的时候调用copy方法可以解决很多问题</p>
<h4 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a>__block变量存储域</h4><table>
<thead>
<tr>
<th>__block变量的配置存储域</th>
<th style="text-align:center">Block从栈复制到堆得影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td style="text-align:center">从栈复制到堆并被Block持有</td>
</tr>
<tr>
<td>堆</td>
<td style="text-align:center">被Block持有</td>
</tr>
</tbody>
</table>
<p>无论<strong>block配置在什么地方，通过</strong>forwarding持有<strong>block变量，当block释放时，</strong>block也会随之释放。</p>
<h4 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h4><p>存储在栈上的block当它的变量作用域结束时，那么当中截取的<strong>block自动变量也随之释放，所以在外部调用block时可能会引起crash，因为只有调用_Block_copy函数才能持有截获的附有</strong>strong修饰符的变量，<strong><em>因此，block中使用对象类型自动变量时，除以下情形外，推荐调用copy方法</em></strong></p>
<ol>
<li>Block作为函数返回值</li>
<li>将Block赋值给类的附有__strong修饰符的id类型或者Block类型的成员变量</li>
<li>向方法名中含有usingBlock的cocoa框架方法或GCD的API中传递block时</li>
</ol>
<h4 id="block变量和对象"><a href="#block变量和对象" class="headerlink" title="__block变量和对象"></a>__block变量和对象</h4><p>上面提到要持有截获的附有<strong>strong修饰符的变量，需要调用copy方法，还有一种方法实现就是在前面添加</strong>block说明符也同样可以实现。如果Block中使用<strong>weak修饰符又会出现什么情况呢？<br>根据前面的内存管理相关方法猜想得到使用</strong>weak修饰符变量时，可能不会导致crash，但是该变量应该会被置为nil。<br>还有一个需要注意的地方当obj同时指定<strong>block说明符和</strong>autoreleasings修饰符时会导致编译错误</p>
<h4 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h4><p>这个点应该是开发中遇到Block最大的问题了；若果在block中使用附有<strong>strong修饰符的对象类型自动变量，那么当Block从栈复制到堆上时，该对象被Block持有，如果该变量也持有了block变量，那么就很容易产生循环引用。<br>为了避免循环引用，我们可以声明</strong>weak修饰符的变量，并将原变量赋值给该变量，同样的在block内部最好使用<strong>strong修饰符来接收之前使用</strong>weak修饰的变量，这样可以防止变量被释放时引起的crash；另外我们还可以使用<strong>block变量来避免循环引用问题，但是使用</strong>block来解决循环引用时，若果不执行该block则会有循环引用并引起内存泄漏，因为该情况下<strong>block变量即持有block也持有了对象，所以不执行block则对象永远无法执行dealloc方法，只有执行了block，</strong>block变量被赋值为nil,才可以正常执行程序</p>
<h3 id="委托代理"><a href="#委托代理" class="headerlink" title="委托代理"></a>委托代理</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ol>
<li>协议：定义代理和委托的共同接口</li>
<li>委托方：根据指定的协议，委托代理去完成时限指定接口</li>
<li>代理方：根据指定的协议，实现委托需要实现的接口</li>
</ol>
<h5 id="weak修饰符-1"><a href="#weak修饰符-1" class="headerlink" title="weak修饰符"></a>weak修饰符</h5><p>代理属性使用weak修饰符修饰，目的是为了避免循环引用；例如tableVC中，vc强引用tableV，设置代理时，都是让vc成为代理，这样tableV又强引用了tableVC。</p>
<h5 id="代理的使用"><a href="#代理的使用" class="headerlink" title="代理的使用"></a>代理的使用</h5><p>声明的方法不做赘述，使用时需要注意的是判断VC有没有遵循协议设置代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(function)]) &#123;</span><br><span class="line">    [self.delegate respondsToSelector:@selector(function)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="代理总结"><a href="#代理总结" class="headerlink" title="代理总结"></a>代理总结</h5><ol>
<li>具有良好的扩展性</li>
<li>有利于代码的封装</li>
<li>代理更有利于对于代码的阅读，相比于block</li>
</ol>
<h4 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSProxy &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSProxy是一个抽象基类，它为一些表现的像是其他对象替身或者并不存在的对象定义API。一般的，发送给代理的消息被转发给一个真实的对象或者代理本身引起加载一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy初始化。<br>NSProxy实现了包括NSObject协议在内所需的基础方法，但作为一个抽象类它本身不提供初始化方法，所以使用时必须提供一个初始化方法的子类，并且重载 <strong><em>forwardInvocation:</em></strong> 方法和 <strong><em>methodSignatureForSelector:</em></strong> 方法来处理自己没有实现的消息。</p>
<h4 id="NSProxy的组件化"><a href="#NSProxy的组件化" class="headerlink" title="NSProxy的组件化"></a>NSProxy的组件化</h4><p>大的项目都使用组件化开发，NSProxy可以作为delegate回调方式来解耦项目；OC项目大多集成了YYKit，我们可以使用YYTextWeakProxy来当做中间件，代理方以路由形式将YYTextWeakProxy的实例对象以delegate为参数传递给委托方，在委托方定义协议需要遵循的方法，在合适的时间调用，代理方在实现此委托方法就可以成功的接收到回调消息已达到解耦的目的，同时也可以此来实现多继承的效果。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><h5 id="Dispatch-Queue-API"><a href="#Dispatch-Queue-API" class="headerlink" title="Dispatch Queue API"></a>Dispatch Queue API</h5><h6 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h6><table>
<thead>
<tr>
<th>Dispatch Queue种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td>等待现在执行中处理结束</td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td>不等待…</td>
</tr>
</tbody>
</table>
<h6 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h6><p>创建Disaptch Queue的方法，该方法有两个参数，第一个指定queue name，第二个参数若指定为NULL则生成Serial Queue，否则为Concurrent Queue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = disaptch_queue_create(&quot;com.example.zhuhuang.myQueue&quot;,NULL);</span><br></pre></td></tr></table></figure></p>
<h6 id="Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue/Global Dispatch Queue"></a>Main Dispatch Queue/Global Dispatch Queue</h6><p>除了通过dispatch_queue_create去创建队列，我们还可以获取系统提供的标准队列。<br>Main Queue就是主线程中的queue，只有1个，自然也是Serial Queue;而Global有优先级高低之分</p>
<h6 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h6><p>通过dispatch_queue_create生成的队列，都是使用默认优先级相同执行优先级的线程。而变更优先级就需要用到dispatch_set_target_queue函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.zhuhuang&quot;,NULL);</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class="line">dispatch_set_target_queue(queue,globalQueue);</span><br></pre></td></tr></table></figure></p>
<p>将第二个Dispatch Queue的优先级指定给第一个Dispatch Queue，不可将系统的Dispatch Queue作为第一个参数</p>
<h6 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ull * NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(),^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>值得注意的是dispatch_after不是在指定时间后处理，而是在指定时间后追加到Dispatch Queue中处理</p>
<h6 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h6><p>在追加到Disaptch Queue种的处理全部结束后再执行某个处理，这种只使用一个Serial Disaptch Queue就可以处理；但是如果使用了Concurrent Disaptch Queue或者多个Dispatch Queue时，就会变得复杂起来；在这种情况下就需要使用Dispatch Group<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = disaptch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class="line">dispatch_group_t group = disaptch_group_create();</span><br><span class="line">dispatch_group_async(group,queue,^&#123;...&#125;);</span><br><span class="line">dispatch_group_async(group,queue,^&#123;...&#125;);</span><br><span class="line">dispatch_group_async(group,queue,^&#123;...&#125;);</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class="line">dispatch_release(group);</span><br></pre></td></tr></table></figure></p>
<h6 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h6><p>在访问数据库或文件时，通过多线程操作时经常会出现数据竞争情况，导致获得的结果有误差，严重的可能导致crash。写入处理不可与其他写入处理以及包含读取处理的其他处理并行执行，但是如果读取处理是可以并行处理并不产生问题的。<br>为了高效的进行访问，读取处理追加到Concurrent Dispatch Queue中，写入处理在任意一个没有读取处理的状态下，卓驾到Serial Dispatch Queue中就可以了。<br>这种情况下 我们有了一个更实用的API，dispatch_barrier_async。<br><strong><em>不管是同步栅栏还是异步栅栏都必须与自定义的Concurrent Dispatch Queue配合使用，不然无法起到栅栏的效果，同步栅栏与dispatch_get_main_queue()一起使用会造成死锁</em></strong></p>
<h6 id="disaptch-sync"><a href="#disaptch-sync" class="headerlink" title="disaptch_sync"></a>disaptch_sync</h6><h6 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h6><p>该函数可能是我们在平时用的较多的GCD的Api之一，是disaptch_sync与Dispatch Group的关联API。按指定的次数将指定的Block追加到指定的Dispatch Queue中，并等待处理全部结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class="line">    NSLog(@&quot;%zu&quot;,index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h6 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h6><h6 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h6><p>当并行执行的处理更新数据时，会产生数据竞争的问题,严重时还会导致crash。在这里通过Serial Disaptch Queue和dispatch_barrier_async函数可以避免类似问题，但是我们还需要更细力度的控制<br>Disaptch Semaphore是持有计数的信号，该计数是多线程编程中的计数类型信号。计数为0时等待，计数为1或大于1的时，减去1而不等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,1ull * NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_semaphore_wait(semaphore,time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">    //这时可以执行需要进行排他控制的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h6><p>dispatch_once函数式保证在应用程序执行中只执行一次指定处理的API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t once;</span><br><span class="line">dispatch_once(&amp;once,^&#123;</span><br><span class="line">    // 单例的初始化</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h6 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h6><p>在读取较大文件时，如果将文件分成合适的大小并使用Global Dispatch Queue并列读取的话，应该会比一般的读取速度要快很多。现在输入/输出硬件已经可以做到一次使用多个线程更快的并列读取了，Disaptch I/O和Disaptch Data就是用来实现这一功能的。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>NSOperation和NSOperationQueue是苹果提供的一套多线程解决方案。实际上是基于GCD完全面向对象的一层封装；但相比较于GCD更简单易用，代码可读性也更高。</p>
<h5 id="Why-NSOperation？"><a href="#Why-NSOperation？" class="headerlink" title="Why NSOperation？"></a>Why NSOperation？</h5><ol>
<li>可添加完成的代码块，在操作完成后执行</li>
<li>添加操作之间的依赖关系，方便管理执行顺序</li>
<li>设定操作执行的优先级</li>
<li>可以方便的取消某个操作</li>
<li>使用KVO观察对操作的执行状态的更改：isExecuteing、isFinished、isCancelled</li>
</ol>
<h5 id="NSOperation操作和操作队列"><a href="#NSOperation操作和操作队列" class="headerlink" title="NSOperation操作和操作队列"></a>NSOperation操作和操作队列</h5><p>操作（NSOperation）：</p>
<ol>
<li>执行操作，即在线程中执行的某段代码</li>
<li>在GCD中是放在Block中，在NSOperation中，我们使用NSOperation子类<strong><em>NSInvocationOperation、NSBlockOperation</em></strong>，或者自定义的子类来封装操作<br>操作队列（Operation Queue）：</li>
<li>存放操作的队列。不同于GCD的调度队列FIFO（先进先出）原则。NSOperationQueue对于添加到队列中的操作，先进入就绪状态（取决于操作之间的依赖关系），然后就绪的操作开始执行顺序（非结束执行顺序）由操作之间相对优先级决定（优先级是操作对象自身的属性）。</li>
<li>操作队列通过设置最大并发数（maxConcurrentOperationCount）来控制并发、串行</li>
<li>NSOperationQueue为我们提供两种不同类型的队列：主队列和自定义队列（主队列运行在主线程上，自定义队列在后台执行）。</li>
</ol>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p>NSThread是苹果官方提供的面向对象操作线程的技术，简单方便；同时NSThread是封装成都最小最轻量级的，使用更灵活，但是要手动管理线程的生命周期、线程同步和线程加锁等，开销较大。</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><ol>
<li>临界区:指的是对一块公共资源访问的代码</li>
<li>自旋锁:用于多线程同步的一种锁，线程反复检查锁变量是否可用。<strong><em>OSSPinLock(不再安全),os_unfair_lock(苹果官方替代方案)</em></strong></li>
<li>互斥锁:用于多线程编程中，防止两条线程同时对一公共资源进行读写的机制。 <strong><em>NSLock,pthread_mutex,@synchronized</em></strong></li>
<li>读写锁:计算机程序的并发控制的同步机制，也叫“共享-互斥锁”。<strong><em>pthread_rwlock</em></strong></li>
<li>信号量:更高级别的同步机制，互斥锁可以看做是semaphore在仅取值0/1的特例。<strong><em>dispatch_semaphore</em></strong></li>
<li>条件锁:条件变量，当进程的某些资源要求不满足时就休眠。<strong><em>NSCondition,NSConditionLock</em></strong></li>
<li>递归锁:互斥锁的一种，在同一个线程中要多次获得一个锁，只能使用递归锁，不然会造成死锁<strong><em>不提倡使用递归锁</em></strong>。<strong><em>NSRecursiveLock,pthread_mutex</em></strong></li>
</ol>
<p><strong><em>死锁：通常指两个线程由于某些原因处于相互等待而都不能完成的</em></strong></p>
<h3 id="KVC-KVO"><a href="#KVC-KVO" class="headerlink" title="KVC-KVO"></a>KVC-KVO</h3><h4 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h4><p>KVC(key-value coding)键值编码，开发中允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值，而不需要调用明确的存取方法（在运行时动态的访问和修改对象的属性）。很多高级的iOS开发技巧都是通过这一特性来实现的。<br>KVC的定义都是通过对NSObject的扩展来实现的，OC中有个显示的NSKeyValueCoding类别名，所以对于所有继承了NSObject的类型，都能使用KVC。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p>
<h5 id="KVC底层原理"><a href="#KVC底层原理" class="headerlink" title="KVC底层原理"></a>KVC底层原理</h5><ol>
<li>寻找该属性有没有设置setter方法，有就直接赋值</li>
<li>寻找有没有该属性带下划线的成员属性有就直接赋值（类方法accessInstanceVairablesDirectly返回值为YES的情况下才可以执行该步骤）</li>
<li>寻找有没有该属性的成员属性有就直接赋值（没找到调用setValue:forUnderfinedKey:)</li>
</ol>
<h5 id="KVC运用场景"><a href="#KVC运用场景" class="headerlink" title="KVC运用场景"></a>KVC运用场景</h5><ol>
<li>动态的取值和塞值</li>
<li>访问修改私有变量（iOS13以后可能会导致crash）</li>
<li>用于model的转换</li>
<li>修改一些控件内部属性（同2）</li>
<li>操作集合</li>
<li>实现KVO</li>
</ol>
<h5 id="KVC异常处理"><a href="#KVC异常处理" class="headerlink" title="KVC异常处理"></a>KVC异常处理</h5><p>根据KVC的搜索规则，没有搜到对应的key或者keyPath，则会调用对应的异常方法。默认实现的异常方法会在异常时抛出一个NSUndefinedKeyException的异常，并且Crash。<br>我们可以通过重写以下方法，根据业务需求合理的处理KVC导致的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<p>另外当通过KVC给某个非对象的属性赋值为nil时，此时KVC会调用属性对象的setNilValueForKey:方法，并抛出NSInvalidArgumentException的异常，导致Crash。<br>该情况下可以通过重写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>KVO（key-value Observing）键值观察，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的变化，并在改变时接收到事件。<br>KVO和NSNotificationCenter都是iOS中观察者模式的一种实现，区别在于，相对于观察者和观察者之间的关系，KVO是一对一的，KVO对被监听对象无侵入性。<br>KVO可以监听单个属性的变化，也可以监听集合对象的变化。通过KVC的mutableArrayValueForKey:等方法获得代理对象，当代理对象内部对象发生改变时，会回调KVO的监听方法（NSArray，NSSet)</p>
<h5 id="KVO底层原理"><a href="#KVO底层原理" class="headerlink" title="KVO底层原理"></a>KVO底层原理</h5><p>KVO是通过isa-swizzling技术实现的。在运行时根据原类A创建一个中间类NSKVONotifying_A，并将被观察的类A的isa指针指向中间类NSKVONotifying_A，然后重写中间类的set方法，在set方法中对被观察的属性值储存并发出通知，同时也在其中调用父类A的set方法。（苹果重写了中间类的class方法 返回原类的class，这么做是为了隐藏中间类，屏蔽内部实现）</p>
<h3 id="NSRunloop"><a href="#NSRunloop" class="headerlink" title="NSRunloop"></a>NSRunloop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">functino loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quit);</span><br><span class="line">&#125;  Event Loop</span><br></pre></td></tr></table></figure>
<p>一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出。这种模型通常被称为EventLoop。实现这种模型的关键点在于如何管理消息、事件，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>所以RunLoop实际上是一个对象，这个对象管理了需要它处理的事件和消息，并提供一个入口函数来执行上面的EventLoop逻辑。线程执行这个函数后，就会一直处于函数内部的“接受消息-&gt;等待-&gt;处理”的循环中，知道这个循环结束，函数返回。<br>iOS/OSX系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。<br>CFRunLoopRef是在CoreFoundation框架内的，它提供了纯C函数的API，所有这些API都是线程安全的。<br>NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，但这些API不是线程安全的。</p>
<h4 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h4><p>苹果不允许直接创建RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread);</span><br><span class="line">    if (!loop)&#123;</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic,thread,loop);</span><br><span class="line">        _CFSetTSD(...,thread,loop);</span><br><span class="line">    &#125;</span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码不难看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary中。线程刚创建时并没有RunLoop，如果你不主动获取，那它一直都不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时。你只能在一个线程内部获取其RunLoop（主线程除外）</p>
<h4 id="RunLoop对外接口"><a href="#RunLoop对外接口" class="headerlink" title="RunLoop对外接口"></a>RunLoop对外接口</h4><ol>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef<br>意思即使字面意思，其中CFRunLoopModeRef并不对外暴露，而是通过CFRunLoopRef的接口进行封装。对应关系如下：<br>一个RunLoop包含若干个Mode，每个Mode又包含Source、Timer、Observer。每次调用RunLoop时，只能指定其中一个Mode，这个Mode称为CurrentMode。切换Mode时需要退出loop，再重新指定一个Mode进入。这样做的原因是为了分隔开不同组的Source、Timer、Observer，让其不互相影响。<br>CFRunLoopSourceRef：事件产生的地方，包含Source0、Source1。</li>
<li>Source0：只包含一个回调（函数指针），不能主动触发事件。使用时，需要先调用CFRunLoopSourceSignal(source)，将这个source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件</li>
<li>Source1：包含一个mach_port和一个回调，备用于通过内核和其他线程相互发送消息，能主动唤醒RunLoop<br>CFRunLoopTimerRef是基于事件的触发器，它和NSTimer可以混用。其包含一个事件长度和一个回调。当其被加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒执行那个回调。<br>CFRunLoopRefObserver是观察者，每个Observer都包含一个回调，当RunLoop状态发生改变时，观察者就能通过回调接受到这个改变。可以观测的时间点如下：</li>
<li>kCFRunLoopEntry //即将进入loop</li>
<li>kCFRunLoopBeforeTimers //即将进入Timer</li>
<li>kCFRunLoopBeforeSources //即将进入Source</li>
<li>kCFRunLoopBeforeWaiting //即将进入休眠</li>
<li>kCFRunLoopAfterWaiting //刚从休眠中唤醒</li>
<li>kCFRunLoopExit //即将退出loop<br>上面的Timer、Source、Observer统称为mode item，一个item可以被同时加入多个mode。但一个item被重复加入同一个mode时无效。如果一个mode中一个item都没有，则RunLoop会直接退出，不进入循环。<br>因为RunLoop在一个时间只能执行一个Mode，所以苹果引入了一个“CommonModes”的概念。一个Mode可以将自己标记为“Common”属性（通过设置ModeName添加到RunLoop的“CommonModes”中）。每当RunLoop的内容发生改变时，RunLoop都会自动将_commonModeItems里的Source/Observer/Timer同步到具有“common”标记的所有Mode里。<br>常见的场景就是在ScrollView中添加一个NSTimer，当页面滑动时NSTimer将失效，滑动结束后NSTimer将继续作用。原因就是ScrollView滑动的状态是被标记在UITrackingRunLoopMode中，而App平时的状态是KCFRunLoopDefaultMode，当Timer被加入到DefaultMode时，页面滑动会切换Mode，timer就不会回调了。想Timer起作用，就需要将Timer分别加入到两种不同的Mode或者将Timer加入到CommonModes中。</li>
</ol>
<h4 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a>RunLoop的底层实现</h4><h4 id="RunLoop的应用场景"><a href="#RunLoop的应用场景" class="headerlink" title="RunLoop的应用场景"></a>RunLoop的应用场景</h4><h5 id="AutoReleasePool"><a href="#AutoReleasePool" class="headerlink" title="AutoReleasePool"></a>AutoReleasePool</h5><p>App启动后，主线程在RunLoop里注册了两个Observer，第一个监听事件是Entry，其内回调会调用_objc_autoreleasePoolPush()创建自动释放池，而且优先级最高，保证创建释放池在其他所有回调之前；第二个监听两个事件：BeforeWaiting时调用_objc_autoreoleasePoolPop()和_objc_autoreleasePoolPush()来释放旧的并创建新的自动释放池，Exit时调用_objc_autoreleasePoolPop(),且这个回调优先级最低，保证在所有回调之后。</p>
<h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>苹果注册了一个Source1（基于mach port）用来接收系统事件，其回调函数为__IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件发生后，首先由IOKit.framework生成一个IOHIDEvent事件并有SpringBoard接收。随后用mach port转发给需要的App进程，苹果注册的Source1在这个时候就会触发回调，并调用_UIApplicationHandleEventQueue()进行应用内部的分发。</p>
<h5 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h5><p>当_UIApplicationHandleEventQueue()识别了一个手势，会先调用Cancel将当前的touchesBegin/Move/End系列回调打断。随后将UIGestureRecognizer标记为待处理。<br>苹果注册了一个Observer监测BeforeWaiting事件，这个Observer回调函数是_UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行回调</p>
<h5 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h5><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>NSTimer注册到RunLoop后，RunLoop会为其重复的时间点注册号事件。RunLoop为了节省资源，并不会非常准确的在这个时间点回调Timer。Timer有个属性叫Tolerance，标识了当时间点到后，容许最大的误差。如果某个点错过了，例如执行一个很长的任务，那该时间点的回调也会被跳过，不会延后执行。<br>CADisplayLink是一个和屏幕刷新率一致的定时器。如果在两次刷新间执行了一个长任务，那其中就会有一帧被跳过去（和NSTime相似），造成界面卡顿的感觉。</p>
<h5 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h5><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>指将数据类型的确定由编译时推迟到运行时，是一套比较底层的纯C语言API主要用于以下几个地方，</p>
<ol>
<li>给系统分类添加属性、方法</li>
<li>交换方法</li>
<li>获取对象的私有属性</li>
<li>字典模型转换</li>
<li>KVC、KVO</li>
<li>编码、解码</li>
<li>获取类名</li>
<li>block</li>
<li>…<h4 id="Runtime数据结构分析"><a href="#Runtime数据结构分析" class="headerlink" title="Runtime数据结构分析"></a>Runtime数据结构分析</h4>OC中，类、对象和方法都是结构体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Class是一个objc_class结构类型的指针，id是一个objc_object结构类型的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;//Class类型的指针，实例对象的isa指向Class，Class的isa指向metaClass</span><br><span class="line">    Class super_class</span><br><span class="line">    const char *name</span><br><span class="line">    long version</span><br><span class="line">    long info</span><br><span class="line">    long instance_size //类实例变量大小</span><br><span class="line">    struct objc_ivar_list *ivars //成员变量链表</span><br><span class="line">    struct objc_method_list **methodLests //方法链表</span><br><span class="line">    struct objc_cache *cache //指向最近调用的方法，对于方法调用的优化机制</span><br><span class="line">    struct obj_protocol_list //协议链表</span><br><span class="line">&#125;；</span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete</span><br><span class="line">    int method_count</span><br><span class="line">    struct objc_method method_list[1]</span><br><span class="line">&#125;</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char *method_types</span><br><span class="line">    IMP method_imp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Runtime消息机制"><a href="#Runtime消息机制" class="headerlink" title="Runtime消息机制"></a>Runtime消息机制</h4><p>类的消息发送的核心方法就是objc_msgSend，通过objc_msgSend方法我们可以知道接收方法对象，查找对象上对应的objc_method，以及传递参数给这个类，最后将返回值传递回来。</p>
<ol>
<li>消息发送给对象时，消息传递函数遵循对象的isa指针指向类结构的指针，在该结构中它查询结构体变量methodLists中的方法SEL</li>
<li>如在isa指向的类结构体中找不到SEL，objc_msgSend会沿着指向superClass指针并再次查找SEL</li>
<li>如连续失败直到NSObject类，则会进行消息转发</li>
<li>如果找到SEL，该函数就会调用methodLists的方法并将接收对象的指针传给它<br>这中间有个概念叫<strong><em>加速消息转发</em></strong><br>OC中的类基本都有继承关系，这就导致methodLists方法较多，查找过程中难免拖累运行速度，所以在Apple在开发的时候加入cache的概念，即缓存。每个类都有一个单独的缓存，它可以包含继承过来的SEL以及在即的自定义SEL，在搜索methodLists之前，消息传递程序会检查接收者对象的缓存cache，如果找到，就不会去搜索methodLists列表。理论上说cache缓存的是一些会再次调用的SEL，所以基本发送过的SEL都会在cache中找到；且cache是动态增长的，会容纳新的消息，知道整个程序中所有调用的SEL运行一遍为止<br><strong><em>规避动态绑定的方法，获取方法地址</em></strong><br>代码正常编译时，需要使用消息传递objc_msgSend才能找到方法的IMP，这中间就有了消息传递的过程，有时候我们不希望调用消息传递，或者节省消息传递的开销，就需要拿到方法的IMP<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(setName:)];</span><br><span class="line">setter(self, @selector(setName:), YES);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong><em>传递给方法实现的前两个参数是接收对象（self）和方法选择器对象（SEL），这些参数是隐藏在方法的语法中了，当方法作为函数被调用时，必须使隐藏的参数显化</em></strong><br>使用methodForSelector可以绕过动态绑定的传递过程，该方法由cocoa运行时提供。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>前面提到消息传递过程会沿着继承的类中一直查找methodLists，知道找到对应的SEL，如果找不到会做消息转发。iOS的消息转发机制，可以有效的解决我们在忘记声明方法而导致的crash问题，当然这个点可以在开发阶段就可以解决，在这主要想说的是在运行时动态的去添加接收者中<strong><em>未知</em></strong>方法的实现。</p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel实例方法解析</span><br><span class="line">+ (BOOL)resolveCalssMethod:(SEL)sel类方法解析</span><br></pre></td></tr></table></figure>
<p>当运用消息转发时，首先根据接收对象选择上述两个方法种的一个，返回BOOL类型，告知系统消息是否被处理</p>
<h5 id="后备接受者对象"><a href="#后备接受者对象" class="headerlink" title="后备接受者对象"></a>后备接受者对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>当动态方法解析没有处理方法时，系统会让另一个对象B来处理这个方法，如果B能处理该方法，那么消息转发结束，方法被B处理。<strong><em>将未知的SEL作为参数传入，寻找另外对象处理，如果可以处理，返回该对象</em></strong></p>
<h5 id="消息签名"><a href="#消息签名" class="headerlink" title="消息签名"></a>消息签名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>
<p>当后背接收者也无法处理SEL时，上述两个方法是最后寻找IMP的机会</p>
<ol>
<li>将未知SEL作为参数传入methodSignatureForSelector，在该方法中处理SEL，如果能够处理，返回方法签名让后续forwardInvocation来进行处理</li>
<li>在forwardInvocation中我们可以用很多方法来处理这个方法签名</li>
</ol>
<p>如果通过以上方法都无法处理SEL，则会抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure></p>
<p>理论上我们可以重载这个函数保证不抛出异常</p>
<h4 id="Runtime实际应用"><a href="#Runtime实际应用" class="headerlink" title="Runtime实际应用"></a>Runtime实际应用</h4><h5 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h5><p>通过runtime根据key来对应的property属性名称进行赋值。<br><strong><em>class_copyPropertyList获取类中所有的属性</em></strong>ps 通过该方法获取的属性，并不受ARC控制需要手动释放</p>
<h5 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h5><p>解耦开发过程，Router、Mediator</p>
<h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>响应者对象UIResponder，只有继承UIResponder的类，才能处理事件。通过.h文件可以知道UIApplication、UIView、UIViewController等都是继承自UIResponder，可以响应处理对象</p>
<h4 id="事件的分发与传递"><a href="#事件的分发与传递" class="headerlink" title="事件的分发与传递"></a>事件的分发与传递</h4><ol>
<li>当iOS程序发生触摸后系统通过RunLoop的Source触发一个事件，并将事件加入到UIApplication管理的任务队列当中</li>
<li>UIApplication将处于任务队列最前端的事件分发给UIWindow</li>
<li>UIWindow将事件向下分发给UIViewController</li>
<li>UIViewController降任务向下分发给UIView</li>
<li>UIView会判断自身是否可以处理事件，如果不能则寻找能处理的子View</li>
<li>遍历完找不到处理者，则处理者为自己，而自己不能处理则不作响应</li>
</ol>
<h4 id="寻找合适的响应对象"><a href="#寻找合适的响应对象" class="headerlink" title="寻找合适的响应对象"></a>寻找合适的响应对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;//返回本次点击事件最佳View</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;//判断一个点是否在范围内</span><br></pre></td></tr></table></figure>
<p>事件传递给控件后，就会调用hitTest:withEvent:方法寻找更合适的View，如果是子View则在子View中继续调用该方法，一直遍历下去，直到找到最合适的View或者废弃事件。当父视图的userInteractionEnabled关闭时，return nil，子视图无法继续查找。<br>扩大按钮的响应范围 也可以使用上面方法改进</p>
<h4 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h4><p>响应链是从最合适的view开始传递，处理事件传递给下一个响应者，响应者链的传递方向是事件传递的反方向，若果所有响应者都不处理事件，则时间丢弃。获取下一个响应者方法是UIResponder的nextResponder方法<br>subView -&gt; View -&gt; ViewController -&gt; Window -&gt; Application -&gt; ApplicationDelegate</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><ol>
<li>layoutSubviews：初始化不会触发，设置frame时会触发；addSubview、滚动ScrollView、旋转Screen、改变View的大小。</li>
<li>setNeedsLayout：标记为需要重新布局，不立即刷新。当调用layoutSubviews时一定会被调用，并配合layoutIfNeeded立即更新</li>
<li>layoutIfNeeded：如果有需要刷新的标志，则立即调用layoutSubviews进行布局。需要在动画中调用该方法，否则layout的动画无效</li>
<li>setNeedsDisplay</li>
<li>drawRect：用来重绘View的。如果UIView的初始化没有设置大小，导致该方法不被自动调用；在sizeToFit后被系统自动调用；设置contentMode为Redraw时，将在frame设置或更改后自动调用；直接调用setNeedsDisplay时会触发（前提条件是rect不能为0）</li>
<li>sizeThatFits</li>
<li>sizeToFit：自动调用sizeToThatFits，不应该在子类中被重写，需要重写sizeToThatFits，只对自身负责<br>以上为layout中常用的几个方法</li>
</ol>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP属于应用层，是一个简单请求响应协议，常见方法有<strong><em>GET、HEAD、PUT、POST、DELETE等</em></strong>。<br>请求头：包含了对客户端环境描述、请求信息等：请求方法、Host、User-Agent、Accept。<br>请求体：客户端发给服务端的具体数据<br>响应头：含了对服务器的描述和对返回数据的描述：http版本、状态码、Server、Content-Type、Date<br>响应体：服务器返回的具体数据<br>一个请求过程会做以下几件事</p>
<ol>
<li>DNS Lookup：域名解析，通过域名获取IP</li>
<li>TCP Handshake：通信过程由TCP来支持，完成传输层的功能；包含TCP的三次握手（client发送syn=j包到server，并进入SYN_SENT状态，等待server确认；server收到syn包，确认client的SYN ack = j+1,同时自己发送syn=k包，即SYN+ACK包，server进入SYN_RECV状态；client收到server的SYN+ACK包，想server发送确认包ACK ack=k+1,发送完毕后,client和server进入ESTABLISHEN状态，完成三次握手）</li>
<li>TLS/SSL Handshake：SSL是运行在TCP/IP层之上、应用层之下，为应用层提供加密数据通道；HTTPS比较消耗新能，主要体现在SSL握手消耗的时间上，</li>
<li>TCP/HTTP Request/Response<br><strong><em>可以从优化DNS解析和缓存、网络质量检测等方式来提升性能</em></strong><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3></li>
</ol>
<h3 id="数据安全与加密"><a href="#数据安全与加密" class="headerlink" title="数据安全与加密"></a>数据安全与加密</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h3><h3 id="cocoapods插件化开发"><a href="#cocoapods插件化开发" class="headerlink" title="cocoapods插件化开发"></a>cocoapods插件化开发</h3><h3 id="自动化打包与编译脚本开发"><a href="#自动化打包与编译脚本开发" class="headerlink" title="自动化打包与编译脚本开发"></a>自动化打包与编译脚本开发</h3><h3 id="跨平台了解"><a href="#跨平台了解" class="headerlink" title="跨平台了解"></a>跨平台了解</h3><h3 id="逆向开发"><a href="#逆向开发" class="headerlink" title="逆向开发"></a>逆向开发</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Category-NSInvocation通信方案" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2016/08/13/Category-NSInvocation通信方案/" class="article-date">
      <time datetime="2016-08-12T16:00:00.000Z" itemprop="datePublished">2016-08-13</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2016/08/13/Category-NSInvocation通信方案/">Category+NSInvocation通信方案(CTMediator)</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>Category作为iOS开发者肯定不陌生，它的主要作用就是不改变原有类的前提下，动态的给这个类添加一些方法。Category还有很多有点，详情请参考<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html#//apple_ref/doc/uid/TP40008195-CH5-SW1" target="_blank" rel="noopener">category</a></p>
<h4 id="Category重名方法"><a href="#Category重名方法" class="headerlink" title="Category重名方法"></a>Category重名方法</h4><p>Category在编译器会生成class的实例方法列表 methodLists 和属性列表 properties，这两者跟class区别就是在命名规则遵循了公共前缀+类名+category名字的命名方式；然后会生成初始化自身的方法<code>OBJC$_CATEGORYClass$_category</code>；最后，编译器在DATA段下的objc_catlist section里保存一个大小为1的category_的数组（ps多个category，会生成对应的长度），用于运行期的category加载。<br>当重名方法实现时，就看谁最后被加入到methodLists中，后面的会覆盖前面的方法，想要更改执行顺序可以在<code>Target-&gt;Build Phases-&gt;Compile Sources</code>更改对应的category的顺序</p>
<h4 id="Category关联对象"><a href="#Category关联对象" class="headerlink" title="Category关联对象"></a>Category关联对象</h4><p>我们知道在category里面无法添加实例变量。但是很多时候需要在category中添加和对象关联的值，这个时候可以通过关联对象来实现<br>MyClass+Category.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;MyClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface MyClass (Category)</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>MyClass+Category.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Myclass+Category.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation MyClass (Category)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    NSLog (@&quot;%@&quot;,@&quot;load in Category&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name &#123;</span><br><span class="line">    objc_setAssociatedObject(self,&quot;name&quot;,name,OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    NSString *nameObject = objc_getAssociatedObject(self,&quot;name&quot;);</span><br><span class="line">    return nameObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>以上就是通过关联对象实现给Category添加属性，新的问题关联对象的存储，对象销毁时关联对象的处理暂时不做讨论，有兴趣的同学可以自己去研究。</p>
<h3 id="NSInvocation"><a href="#NSInvocation" class="headerlink" title="NSInvocation"></a>NSInvocation</h3><p>NSIncocation经常被用在对象和app间存储和转发消息；一个NSInvocation对象包含了一个消息的所有元素：接收对象、方法选择器、参数和返回值，且这些元素在NSInvocation对象分发时都可以被修改。<br>一个NSInvocation对象可以被重复的发送个不同的接收者，它的参数也可以针对不同的结果在分发时进行修改，甚至它的方法也可以被替换，在这个方法的签名相同（ps:参数和返回类型相同）的情况下。<br>NSInvocation不支持使用可变参数的初始化方法，你只能使用<code>invocationWithMethodSignature:</code>去创建对象而不是使用<code>alloc、init</code>。<br><strong><em>NSInvocation遵循NSCodeing协议，但是它只支持NSPortCoder协议，不支持对象的归档</em></strong></p>
<h3 id="CTMediator通信方案"><a href="#CTMediator通信方案" class="headerlink" title="CTMediator通信方案"></a>CTMediator通信方案</h3><p><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">CTMediator</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构设计/">架构设计</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Cocoapods静态库整理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2016/04/08/Cocoapods静态库整理/" class="article-date">
      <time datetime="2016-04-07T16:00:00.000Z" itemprop="datePublished">2016-04-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2016/04/08/Cocoapods静态库整理/">Cocoapods静态库整理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>#为何选择CocoaPods做静态库</p>
<p>公司项目框架比较大，为了以后业务发展，需要将项目分包，所以将项目的通用工具、网络层与基类封成一个基础包；开始准备将这个基础包打成framework，但考虑到以后业务也需要打包时不好引入基础包的依赖，遂将基础包做成了一个私有库供团队维护与后期开发。</p>
<p>Cocoapods创建私有库</p>
<p>1.创建私有repo</p>
<p>在你的git服务器上创建一个仓库。因为github上私有仓库是收费的，大家可以自己选择git服务器。</p>
<p>创建好仓库以后我们可以执行：</p>
<p>pod repo add [repo_name] [repo_url]<br>repo_name使我们的仓库的名称，repo_url为仓库地址(ps:优先使用https地址，使用ssh地址时需要配置git的SSH keys)，成功后可以前往文件夹 ~/.cocoapods/repos会看到思库内容</p>
<p>2.创建自己的Cocoapods依赖库</p>
<p>1.首先在git上创建一个仓库，记得添加license文件和remamd文件。</p>
<p>2.clone仓库到本地</p>
<p>cd ~</p>
<p>git clone [repo_url]<br>3.向本地仓库提交文件</p>
<p>新建一个类似文件夹目录结构，将代码.h.w或者.swift文件放在Calssses文件夹中</p>
<p>在Assets文件夹下放入一个bundle资源文件包</p>
<p>4.生成podspec文件并编辑</p>
<p>cd ~/[project_name]</p>
<p>pod spec create [project_name]<br>打开该文件修改内容为</p>
<p>s.source表示项目在git上的地址</p>
<p>s.source_files表示代码文件地址</p>
<p>s.resources表示资源文件地址</p>
<p>s.frameworks表示对系统库的依赖</p>
<p>s.depency表示对第三方库的依赖<br>5.Demo工程</p>
<p>你可以在该文件下添加demo指导别人使用</p>
<p>3.将代码提交到git</p>
<p>git add .</p>
<p>git commit -a -m ‘first’</p>
<p>git tag -a 0.1.0 -m ‘first’ (这个tag要与版本号一致）<br>4.验证.podspec文件</p>
<p>pod lib lint xxx.podspec –allow-warnings –use-libraries<br>验证通过后只要将代码推送到git仓库上就可以了</p>
<p>5.将podspec给到私有repo</p>
<p>pod repo push [repo_name] [xxx.podspec]<br>成功后就可以去本地repo地址查看</p>
<p>Cocoapods打包带私有库依赖的framework</p>
<p>pod lib create GTEDXCalendar</p>
<p>What language do you want to use?? [ Swift / ObjC ]</p>
<p>ObjC</p>
<p>Would you like to include a demo application with your library?[ Yes / No]</p>
<p>No</p>
<p>Which testing frameworks will you use ? [ Specta / Kiwi  / None ]</p>
<p>None</p>
<p>Would you like to do view based testing? [ Yes / No ]</p>
<p>No</p>
<p>What is your class prefix ?</p>
<p>GTEDX<br>成功后打开GTEDXCalendar.podspec文件修改</p>
<p>修改方法参考上文</p>
<p>cd ~/GTEDXCalendar/Example</p>
<p>vim Podfile</p>
<p>在头上添加红圈标注的代码</p>
<p>source ‘<a href="https://github.com/CocoaPods/Specs.git&#39;" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git&#39;</a></p>
<p>source private #私有仓库git地址<br>然后执行pod install</p>
<p>将源文件与资源数据放入对应的Classes与Assets文件中</p>
<p>提交源码并打上tag</p>
<p>验证.podspec文件</p>
<p>pod lib lint GTEDXCalendar.podspec –allow-warnings –use-libraries –sources = private , <a href="https://github.com/CocoaPods/Specs.git" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git</a><br>安装插件</p>
<p>sudo gem install coocapods-packager<br>打包</p>
<p>pod package GTEDXCalendar.podspec –force –spec-sources=private , <a href="https://github.com/CocoaPods/Specs.git" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs.git</a><br>使用framework</p>
<p>新建一个工程，新建Podfile文件</p>
<p>在podfile文件中添加source地址</p>
<p>将私有库中与framework的依赖都加入podfile文件中（保持版本一致）</p>
<p>然后将framework加入项目并将framework内部的bundle也拖入项目</p>
<p>参考</p>
<p>使用Cocoapods制作静态库</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cocoapods/">cocoapods</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-GCD使用总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2016/03/03/GCD使用总结/" class="article-date">
      <time datetime="2016-03-02T16:00:00.000Z" itemprop="datePublished">2016-03-03</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2016/03/03/GCD使用总结/">GCD使用总结</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>###什么是GCD<br>GCD全称为Grand Centeral Dispatch，为iOS和OS X的多核硬件上执行提供控制，是意不执行任务的技术之一。<br>开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并执行计划任务。由于线程管理是作为系统的一部分来实现的，因此可以统一管理，也可执行任务，这样就比以前的线程更有效率。举个🌰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue,^&#123;</span><br><span class="line">    /*</span><br><span class="line">    * 长时间任务处理</span><br><span class="line">    *</span><br><span class="line">    * 例如数据库访问</span><br><span class="line">    */</span><br><span class="line">    /*</span><br><span class="line">    * 长时间处理结束，主线程中使用结果</span><br><span class="line">    */</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码就是在后台执行线程中执行长时间处理，处理结束时，主线程使用该处理结果的源代码。</p>
<p>###Dispatch Queue的种类<br>Dispatch queue的种类有两种：一种是等待执行中处理结束的<strong>Serial Dispatch Queue（串行队列）</strong>，另一种是不等待执行中处理的<strong>Concurrent Dispatch Queue（并行队列）</strong>。<br>虽然有了Queue的种类，那么如何才能得到Dispatch queue呢？</p>
<p>####dispatch_queue_create<br>第一中方法是通过GCD的Api生成Dispatch Queue<br><figure class="highlight plain"><figcaption><span>myQueue </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">Serial Dispatch queue可以在创建时用NULL标识；多个线程更新相同资源导致数据竞争时建议使用Serial Dispatch Queue</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t myQueue = dispatch_queue_create(“com.zeuszhang.gcd.myQueue”,DISPATCH_QUEUE_CONCURRENT);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">####Main Dispatch Queue/Global Dispatch Queue</span><br><span class="line">第二种方法是获取系统提供的Dispatch Queue</span><br><span class="line"></span><br><span class="line">Main Dispatch Queue主线程只有一个自然是Serial dispatch queue</span><br><span class="line">dispatch_queue_t myQueue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure></p>
<p>Global Dispatch Queue是所有程序都能够使用Concurrent dispatch queue。另外Global Dispatch queue有4个执行优先级<br>1.High Priority<br>2.Default Priority<br>3.Low Priority<br>4.Background Priority<br>dispatch_queue_t myQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);//第一个参数表示优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_set_target_queue</span><br><span class="line">dispatch_queue_create函数生成的Dispatch Queue不管是Serial dispatch queue还是Concurrent dispatch queue，都使用默认优先级（default）Global Dispatch queue相同执行优先级的线程。而变更生成的Dispatch queue的优先级需要用到dispatch_set_target_queue函数。🌰如下</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t myQueue = dispatch_queue_create(“com.zeuszhang.gcd.myQueue”,NULL);<br>dispatch_queue_t globalQueueBackground = dispatch_queue_create(DISPATCH_QUEUE_PRIORITY_BACKROUND,0);<br>dispatch_set_target_queue(myQueue,globalQueueBackground);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">指定变更优先级的Dispatch Queue为dispatch_set_target_queue函数第一个参数，指定要使用的执行优先级的Global dispatch queue为第二个参数；**ps（第一个参数不可指定为系统提供的Main Dispatch Queue或者Global Dispatch Queue）**</span><br><span class="line"></span><br><span class="line">###dispatch_after</span><br><span class="line">GCD延时函数</span><br></pre></td></tr></table></figure></p>
<p>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull * NSEC_PER_SEC);<br>dispatch_after(time,dispatch_get_main_queue(),^{<br>    NSLog(@”waited at least three seconds”);<br>})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要注意的是dispatch_after函数并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。</span><br><span class="line"></span><br><span class="line">###Dispatch Group</span><br><span class="line">在Dispatch Queue中处理多个全部结束后想执行的操作，就可以使用Dispatch Group来使代码更简单</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_group_t group = dispatch_group_create();<br>dispatch_group_async(group,queue,^{NSLog(@”b1k0”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k1”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k2”);});<br>dispatch_group_notify(group,dispatch_get_main_queue(),^{NSLog(@”dine”);});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在dispatch_group_notify函数中不管制定什么样的Dispatch Queue，属于Dispatch Group的全部处理再追加制定的Block时都已经执行结束。另外，在Dispatch Group中也可以使用dispatch_group_wait函数仅等待全部处理执行结束。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_group_t group = dispatch_group_create();<br>dispatch_group_async(group,queue,^{NSLog(@”b1k0”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k1”);});<br>dispatch_group_async(group,queue,^{NSLog(@”b1k2”);});<br>dispatch_group_wait(group,DISPATCH_TIME_FORVER);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait函数的第二个参数指定为等待时间属于dispatch_time_t类型的值</span><br></pre></td></tr></table></figure></p>
<p>dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);<br>long result - dispatch_group_wait(group,time);<br>if (result == 0) {<br>    //group的处理全部结束<br>} else {<br>    //group处理中<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果dispatch_group_wait的返回值不为0，就意味着虽然过了指定的时间，但group中还有处理没有结束；若为0，则全部处理执行完毕。当等待时间为DISPATCH_TIME_FOREVER,由group的处理必定全部结束。</span><br><span class="line"></span><br><span class="line">###dispatch_barrier_async</span><br><span class="line">在访问数据库时，前面说用Serial dispatch queue可以避免数据竞争。写入不可以与读取处理并行操作，但是如果是读写与读写是可以并行的。</span><br><span class="line">也就是为了高效访问，读取处理追加到Concurrent dispatch queue中，写入处理在任一个读取处理没有执行的状态下追加到Serial dispatch queue中即可。虽然用group月dispatch_set_target_queue也可以处理，但代码逻辑复杂，这里提供一个简单方法**dispatch_barrier_async**</span><br><span class="line">🌰：</span><br></pre></td></tr></table></figure></p>
<p>首先生成一个Concurrent dispatch queue在queue中追加读取处理<br>dispatch_queue_t queue = dispatch_queue_create(“com.zueszhang.gcd.forBarrier”,DISPATCH_QUEUE_CONCURRENT);<br>dispatch_async(queue,b1k0_fro_reading);<br>dispatch_async(queue,b1k1_fro_reading);<br>dispatch_async(queue,b1k2_fro_reading);<br>dispatch_async(queue,b1k3_fro_reading);<br>dispatch_barrier_async(b1k_for_writing);<br>dispatch_async(queue,b1k4_fro_reading);<br>dispatch_async(queue,b1k5_fro_reading);<br>dispatch_async(queue,b1k6_fro_reading);<br>dispatch_async(queue,b1k7_fro_reading);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_sync</span><br><span class="line">dispatch_sync就是将指定的block***同步***的追加到指定的Dispatch Queue中，再追加Block结束之前，dispatch_sync函数会一直等待。</span><br><span class="line"></span><br><span class="line">###dispatch_apply</span><br><span class="line">dispatch_apply函数是将dispatch_sync和Dispatch Group关联的api。该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中，并等待全部处理结束</span><br><span class="line">🌰</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_apply(10,queue,^(size_t index) {<br>    NSLog(@”%zu”,index)<br>})<br>NSLog(@”Done”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为在Global Dispatch queue中处理所以线程，所以各个操作时间不定。但是Done肯定是在最后被输出。</span><br><span class="line">第一个参数为重复次数，第二个参数是追加对象的Dispatch Queue，第三个参数为追加的block处理。</span><br><span class="line">常用作与对数组类对象的所有元素执行处理时，可以替代for循环的效果。</span><br><span class="line">另外，由于dispatch_apply函数也与dispatch_sync函数相同，会等待处理执行结束，因此推荐在dispatch_async函数中非同步的执行dispatch_apply</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>//在global dipsatch queue中非同步执行<br>dispatch_async(queue,^{<br>    //等待dispatch_apply函数中全部处理结束<br>    dispatch_apply([array count],queue,^(size_t index){<br>        //并列处理包含在array中的全部对象<br>        NSLog(@”%zu:%@”,index,[array objectAtIndex:index]);<br>    });<br>    //等待完毕后在main中执行处理<br>    dispatch_async(dispatch_get_main_queue(),^{<br>        NSLog(@”Done”);<br>    });<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_suspend / dispatch_resume</span><br><span class="line">当追加大量处理到Disaptch Queue时，再追加处理的过程中，有时希望不执行已追加的处理。例如演算结果被block截获时，一些处理会对这个结果造成影响。这种情况下，只要挂起Dispatch Queue即可，当可执行时再恢复。</span><br><span class="line"></span><br><span class="line">###Dispatch Semaphore</span><br><span class="line">当并行执行的处理更新数据时，会产生数据竞争的可能，有时还会导致程序异常。虽然通过Serial Dispatch Queue和dispatch_barrier_async函数可以避免这类问题，但是有必要更细力度的控制它。</span><br><span class="line">🌰：不考虑排序，将所有数据追加到NSMutableArray中。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>NSMutableArray *array = [[NSMutableArray alloc] init];<br>for (int i = 0; i &lt; 10000; i++) {<br>    dispatch_async(queue,^{<br>        [array addObject:[NSNumber numberWithInt:i]];<br>    });<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此时，使用global更新NSMutableArray对象，所以执行后由内存错误导致程序异常结束概率很高。此时应该使用Dispatch Semaphore。</span><br><span class="line">Dispatch Semaphore是持有计数的信号，该计数是多线程编程中的计数类型信号。在Dispatch Semaphore中，计数为0时等待，计数为1或大于1时，减去1而不等待。</span><br></pre></td></tr></table></figure></p>
<p>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数表示计数的初始值。从函数创建名称中create可以看出，该函数与Dispatch Queue和Dispatch Group一样，必须通过dispatch_release函数释放。</span><br><span class="line">dispatch_semaphore_wait函数等待Dispatch Semaphore的计数值达到大于或等于1。当计数值大于等于1，或者在待机中计数值大于等于1时，对该计数进行减法并从dispatch_semaphore_wait函数返回。第二个参数与dispatch_group_wait函数等相同，由dispatch_time_t类型值指定等待时间。</span><br><span class="line">🌰：</span><br></pre></td></tr></table></figure></p>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);<br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);<br>NSMutableArray *array = [[NSMutableArray alloc] init];<br>for (int i = 0; i &lt; 10000; ++i) {<br>    dispatch_async(queue,^{<br>        dispatch_semaphore_wait(semaphore,DISPATCH_TIME_FOREVER);<br>        [array addObject:[NSNumber numberWithInt:i]];<br>        dispatch_semaphore_signal(semaphore);<br>    })<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###dispatch_once</span><br><span class="line">这个应该是最常用的GCD api了。该函数是保证在应用程序中执行一次指定处理的Api。</span><br><span class="line">iOS单例模式：</span><br></pre></td></tr></table></figure></p>
<p>static id manager = nil;<br>-(id)defaultManager {<br>    static dispatch_once_t once;<br>    dispatch_once(&amp;once,^{<br>        manager = [[self alloc] init];<br>    });<br>    return manager;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###Dispatch I/O</span><br><span class="line">读取较大文件时，如果将文件分成合适的大小并使用Global Dispatch Queue并列读取的话，应该会比一般的读取速度快不少。现今的输入/输出硬件已经可以做到一次使用多个线程更快的并列读取了。能实现这一功能的就是Dispatch I/O和Dispatch Data通过Dispatch I/O读写文件时，使用Global Dispatch Queue将1个文件按某个大小read/write</span><br></pre></td></tr></table></figure></p>
<p>disaptch_async(queue,^{/<em>读取  0 ~ 800字节</em>/});<br>disaptch_async(queue,^{/<em>读取  801 ~ 1600字节</em>/});<br>disaptch_async(queue,^{/<em>读取  1601 ~ 2400字节</em>/});<br>disaptch_async(queue,^{/<em>读取  2401 ~ end</em>/});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像上面这样，将文件分割为一块一块的进行读取处理。分割读取的数据通过使用Dispatch Data可进行更为简单的进行结合和分割</span><br><span class="line">🌰：</span><br></pre></td></tr></table></figure></p>
<p>pipe_q = dispatch_queue_create(“PipeQ”,NULL);<br>pipe_channel = dispatch_io_create(DISPATCH_IO_STREAM,fd,pipe_q,^(int err) {<br>    close(fd);<br>})</p>
<p><em>out_fd = fdpair[1];<br>dispatch_io_set_low_water(pipe_channel,SIZE_MAX);<br>dispatch_id_read(pipe_channel, 0, SIZE_MAX, pipe_q,^(bool done,     dispatch_data_t pipedata, int err) {<br>    if (err == 0) {<br>        size_t len = dispatch_data_get_size(pipedata);<br>        if (len &gt; 0) {<br>            const char </em>bytes = NULL;<br>            char <em>encoded;<br>            dispatch_data_t md = dispatch_data_create_map(pipedata,(const void <strong>)&amp;bytes, &amp;len);<br>            encoded -asl_core_encode_buffer(bytes,len);<br>            asl_set((aslmsg)merged_msg,ASL_KEY_AUX_DATA,encoded);<br>            free(encoded);<br>            _asl_send_message(NULL,merged_msg,-1,NULL);<br>            asl_msg_release(merged_msg);<br>            dispatch_release(md);<br>        }<br>    }<br>    if (done) {<br>        dispatch_semphore_signal(sem);<br>        dispatch_release(pipe_channel);<br>        dispatch_release(pipe_q);<br>    }<br>});<br><code>`</code>
</strong></em>同样使用”create”生成的对象最后都要释放。***</p>
<p>###Disaptch Source<br>GCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。他是BSD系内核惯有功能kqueue的包装。<br>kqueue是在XNU内核中发生各种事件时，在应用程序编程方执行处理的技术(ps不重要)。它的CPU负荷非常小，尽量不占用资源。<br>Dispatch Source种类</p>
<table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">种类</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td style="text-align:center">变量增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td style="text-align:center">变量OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td style="text-align:center">端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td style="text-align:center">端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td style="text-align:center">检测到与进程有关的事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td style="text-align:center">可读取文件映像</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td style="text-align:center">接收信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td style="text-align:center">定时器</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td style="text-align:center">文件系统变更</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td style="text-align:center">可写入映像</td>
</tr>
</tbody>
</table>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gcd/">gcd</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-iOS定时器整理对比" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2016/01/21/iOS定时器整理对比/" class="article-date">
      <time datetime="2016-01-20T16:00:00.000Z" itemprop="datePublished">2016-01-21</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2016/01/21/iOS定时器整理对比/">iOS定时器整理对比</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h2><h4 id="什么是NSTimer"><a href="#什么是NSTimer" class="headerlink" title="什么是NSTimer"></a>什么是NSTimer</h4><p>通过官方文档”A timer provides a way to perform a delayed ation or a periodic action. The timer waits until a certain time interval has elapsed and then fires, sending a specified message to a specified objec.”翻译过来就是timer就是一个能从现在开始的后面某个时刻或者周期性的执行我们制定的方法对象。</p>
<h4 id="NSTimer和它调用的函数对象"><a href="#NSTimer和它调用的函数对象" class="headerlink" title="NSTimer和它调用的函数对象"></a>NSTimer和它调用的函数对象</h4><p>从前面官方解释可以看出timer会在未来的某个时刻执行一次或者多次执行我们指定的方法，这也就牵扯出一个问题，如何保证timer触发时，我们指定的方法是有效的呢？答案很简单，就是timer对它的target进行retain，我们需要小心对待target的生命周期问题，尤其是重复性的timer。在timer触发我们指定的方法后，我们需要释放timer，这里提供了invalidate方法，否则被retain的方法内对象将一直存在，造成内存泄漏。</p>
<h4 id="NSTimer会准时触发事件吗？"><a href="#NSTimer会准时触发事件吗？" class="headerlink" title="NSTimer会准时触发事件吗？"></a>NSTimer会准时触发事件吗？</h4><p>这个答案是否定的，而且有时候会发现实际触发时间跟你设定的时间会差距挺大的，这要从NSTimer的实现说起。<br>NSTimer不是一个实时系统，所以timer触发的时机会有误差，差距的大小主要跟当前我们程序的执行情况有关系，比如程序是多线程的，而timer只是添加在某一个线程的Runloop的某一种指定的runloopmode中，由于多线程通常都是分时执行，而且每次执行的mode也可能随着时机情况变化而改变，或者在某一个时刻线程有大量复杂的运算。这些都会导致timer的触发时机不够精准。</p>
<h2 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h2><h4 id="什么是CADisplayLink"><a href="#什么是CADisplayLink" class="headerlink" title="什么是CADisplayLink"></a>什么是CADisplayLink</h4><p>CADisplayLink是一个能让我们以和屏幕刷新率相同的频率将内容绘制到屏幕上的定时器。</p>
<h4 id="CADisplayLink和它调用的函数对象"><a href="#CADisplayLink和它调用的函数对象" class="headerlink" title="CADisplayLink和它调用的函数对象"></a>CADisplayLink和它调用的函数对象</h4><p>我们在应用中创建一个CADisplayLink对象，把它添加到一个RunLoop中，并给他提供一个target和selector在屏幕刷新的时候调用；一旦该对象被以特定模式注册到RunLoop中，每当屏幕刷新时，RunLoop就会主动调用该对象绑定的target上的selector，这时target可以拿到CADisplayLink调用的时间戳，用来准备下一帧的数据。</p>
<h4 id="CADisplayLink的准确性"><a href="#CADisplayLink的准确性" class="headerlink" title="CADisplayLink的准确性"></a>CADisplayLink的准确性</h4><p>iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精度比NSTimer要高很多，但是CADisplayLink适用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的适用范围相对广泛。<br><strong>需要注意的是iOS设备的刷新频率是60HZ，也就是每秒60次。那么每一次刷新时间大约16.7毫秒。当我们的<em>frameInterval</em>的值为1的时候我们需要保证CADisplayLink调用的target的函数计算时间不应该大于16.7否则会出现严重的丢帧现象</strong></p>
<h2 id="GCD-Source"><a href="#GCD-Source" class="headerlink" title="GCD Source"></a>GCD Source</h2><h4 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h4><p>为了避免NSTimer可能存在的风险，我们可以选择使用dispatch_after，使用gcd时系统会帮我们处理线程级的逻辑；除此之外，我们也不需要考虑RunLoop的问题，这样调用对象也不会被持有，上述关于内存泄漏也不存在了。当然，需要注意block可能导致的循环引用问题。<br><strong>但是dispatch_after也有一个很严重的问题，那就是一旦执行后就不能撤销了！！！</strong></p>
<h4 id="dispatch-source"><a href="#dispatch-source" class="headerlink" title="dispatch_source"></a>dispatch_source</h4><p>这个时候我们就可以用GCD本身的timer功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class="line">dispatch_source_t tiemr = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER,0,0,queue);</span><br><span class="line">dispatch_source_set_timer(timer,DISPATCH_TIME_NOW,2.0 * NSEC_PER_SEC,0.1 * NSEC_PER_SEC);</span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">dispatch_source_set_event_handler(timer,&lt;&#123;</span><br><span class="line">    [weakSelf action];</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line">disaptch_source_cancel(timer);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/timer/">timer</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-WKWebView与js的交互" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2015/10/20/WKWebView与js的交互/" class="article-date">
      <time datetime="2015-10-19T16:00:00.000Z" itemprop="datePublished">2015-10-20</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2015/10/20/WKWebView与js的交互/">WKWebView与js交互</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="WKWebview与UIWebView的对比"><a href="#WKWebview与UIWebView的对比" class="headerlink" title="WKWebview与UIWebView的对比"></a>WKWebview与UIWebView的对比</h3><p>UIWebView自iOS2开始就有了，而WKWebView在iOS8以上的设备上才可以使用，毫无疑问WKWebView将逐步取代相对笨重的UIWebView。<br>WkWeb的优势：</p>
<ul>
<li>在性能、稳定性、功能方面有很多大提升</li>
<li>更多的支持HTML5的特性</li>
<li>官宣高达60fps的滚动刷新率以及内置手势</li>
<li>Safari相同的JavaScript引擎</li>
<li>新增加载进度属性等 </li>
</ul>
<h4 id="加载网页"><a href="#加载网页" class="headerlink" title="加载网页"></a>加载网页</h4><p>加载网页或HTML代码方式与UIWebView相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.frame];</span><br><span class="line">[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;www.zeuszhang.com&quot;]]];</span><br><span class="line">[self.view addSubView:webView];</span><br></pre></td></tr></table></figure></p>
<h4 id="加载回调状态"><a href="#加载回调状态" class="headerlink" title="加载回调状态"></a>加载回调状态</h4><p>加载回调状态用来追踪整个家在过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 页面开始加载时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation;</span><br><span class="line">// 当内容开始返回时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation;</span><br><span class="line">// 页面加载完成之后调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation;</span><br><span class="line">// 页面加载失败时调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation</span><br></pre></td></tr></table></figure></p>
<p>页面跳转的代理方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 接收到服务器跳转请求之后调用</span><br><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;</span><br><span class="line">// 在收到响应后，决定是否跳转</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;</span><br><span class="line">// 在发送请求之前，决定是否跳转</span><br><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction</span><br></pre></td></tr></table></figure></p>
<p>新的WKUIDelegate协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//警告框</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(void (^)())completionHandler;</span><br><span class="line">//确认框</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL))completionHandler;</span><br><span class="line">//输入框</span><br><span class="line">- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * _Nullable))completionHandler;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意这几个方法的回调处理不让回crash</em></strong></p>
<h4 id="动态加载并运行js代码"><a href="#动态加载并运行js代码" class="headerlink" title="动态加载并运行js代码"></a>动态加载并运行js代码</h4><p>客户端内部加载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 图片缩放的js代码</span><br><span class="line">NSString *js = @&quot;var count = document.images.length;for (var i = 0; i &lt; count; i++) &#123;var image = document.images[i];image.style.width=320;&#125;;window.alert(&apos;找到&apos; + count + &apos;张图&apos;);&quot;;</span><br><span class="line">// 根据JS字符串初始化WKUserScript对象</span><br><span class="line">WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];</span><br><span class="line">// 根据生成的WKUserScript对象，初始化WKWebViewConfiguration</span><br><span class="line">WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];</span><br><span class="line">[config.userContentController addUserScript:script];</span><br><span class="line">_webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:config];</span><br><span class="line">[_webView loadHTMLString:@&quot;&lt;head&gt;&lt;/head&gt;&lt;imgea src=&apos;http://www.nsu.edu.cn/v/2014v3/img/background/3.jpg&apos; /&gt;&quot;baseURL:nil];</span><br><span class="line">[self.view addSubview:_webView];</span><br></pre></td></tr></table></figure></p>
<p>webview执行js代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//javaScriptString是JS方法名，completionHandler是异步回调block</span><br><span class="line">[self.webView evaluateJavaScript:javaScriptString completionHandler:completionHandler];</span><br></pre></td></tr></table></figure></p>
<p>js调用app注册的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br><span class="line">scriptMessageHandler是代理回调，JS调用name方法后，OC会调用scriptMessageHandler指定的对象。JS在调用OC注册方法的时候要用下面的方式：</span><br><span class="line">window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</span><br></pre></td></tr></table></figure></p>
<p><strong><em>注意name是方法名，参数需要封装到messageBody中</em></strong></p>
<p><strong><em>ps这里有一个重点需要注意的地方</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//OC注册供JS调用的方法</span><br><span class="line">[[_webView configuration].userContentController addScriptMessageHandler:self name:@&quot;closeMe&quot;];</span><br><span class="line">//OC在JS调用方法做的处理</span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;JS 调用了 %@ 方法，传回参数 %@&quot;,message.name,message.body);</span><br><span class="line">&#125;</span><br><span class="line">//JS调用</span><br><span class="line">    window.webkit.messageHandlers.closeMe.postMessage(null);</span><br></pre></td></tr></table></figure></p>
<p>在上述客户端中处理时，会发现self的dealloc方法没有调用，我在这里的解决方案是在当前vc销毁时，手动调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.wkWebView.configuration.userContentController addScriptMessageHandler:self name:@&quot;&quot;];</span><br></pre></td></tr></table></figure></p>
<p>以移除通知的监听方式。</p>
<p><strong><em>pps WKWebViewConfiguration也存在内存泄漏问题</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WKWebViewConfiguration*config = [[WKWebViewConfigurationalloc]init];</span><br><span class="line">config.selectionGranularity = WKSelectionGranularityCharacter;</span><br><span class="line">WKWebView  *webView= [[WKWebViewalloc]initWithFrame:CGRectZero configuration:config];</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 ZeusZhang
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>