<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>iOS知识梳理 | ZeusZhang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="内存管理引用计数引用计数的思考方 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放| 对象操作 | OC方法 || – | :–: || 生成并持有对象 | alloc/new/copy/mutableCopy… || 持有对象 | retain || 释放对象 | release || 废弃对象 | dealloc |以上述方法开头">
<meta name="keywords" content="zeus,zeuszhang,dobulez,iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS知识梳理">
<meta property="og:url" content="http://yoursite.com/2019/04/20/iOS知识梳理/index.html">
<meta property="og:site_name" content="ZeusZhang">
<meta property="og:description" content="内存管理引用计数引用计数的思考方 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放| 对象操作 | OC方法 || – | :–: || 生成并持有对象 | alloc/new/copy/mutableCopy… || 持有对象 | retain || 释放对象 | release || 废弃对象 | dealloc |以上述方法开头">
<meta property="og:locale" content="Objective-C,Swift,JavaScript">
<meta property="og:updated_time" content="2019-12-10T03:06:02.964Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS知识梳理">
<meta name="twitter:description" content="内存管理引用计数引用计数的思考方 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放| 对象操作 | OC方法 || – | :–: || 生成并持有对象 | alloc/new/copy/mutableCopy… || 持有对象 | retain || 释放对象 | release || 废弃对象 | dealloc |以上述方法开头">
  
    <link rel="alternative" href="/atom.xml" title="ZeusZhang" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">ZeusZhang</a></h1>
        </hgroup>
        
        <p class="header-subtitle">zeuszhang blog</p>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/categories/开发工具/">玩转开发工具</a></li>
                        
                            <li><a  href="/categories/digital">玩转数码</a></li>
                        
                            <li><a  href="/categories/algorithm">算法学习</a></li>
                        
                            <li><a  href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="/xxxxx" title="github">github</a>
                            
                                <a class="fl weibo"  target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                            
                                <a class="fl rss"  target="_blank" href="/atom.xml" title="rss">rss</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/cocoapods/" style="font-size: 10px;">cocoapods</a> <a href="/tags/gcd/" style="font-size: 10px;">gcd</a> <a href="/tags/timer/" style="font-size: 10px;">timer</a> <a href="/tags/二进制-cocoapods/" style="font-size: 10px;">二进制 cocoapods</a> <a href="/tags/架构设计/" style="font-size: 10px;">架构设计</a> <a href="/tags/架构设计-block/" style="font-size: 10px;">架构设计 block</a> <a href="/tags/跨平台-flutter/" style="font-size: 10px;">跨平台 flutter</a>
                    </div>
                </section>
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://blog.csdn.net/baidu_21483933">csdn</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="https://segmentfault.com/blog/maocg_web">segmentfault</a>
                    
                      <a target="_blank"  class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/eb37ef89c746/latest_articles">简书</a>
                    
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">爱动漫,爱游戏,爱编程,爱运动,爱的太多了!</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">ZeusZhang</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">ZeusZhang</a></h1>
            </hgroup>
            
            <p class="header-subtitle">zeuszhang blog</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/categories/开发工具/">玩转开发工具</a></li>
                
                    <li><a href="/categories/digital">玩转数码</a></li>
                
                    <li><a href="/categories/algorithm">算法学习</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="/xxxxx" title="github">github</a>
                    
                        <a class="weibo" target="_blank" href="/xxxxxxxx" title="weibo">weibo</a>
                    
                        <a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap"><article id="post-iOS知识梳理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2019/04/20/iOS知识梳理/" class="article-date">
      <time datetime="2019-04-19T16:00:00.000Z" itemprop="datePublished">2019-04-20</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS知识梳理
    </h1>
  


      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><h5 id="引用计数的思考方"><a href="#引用计数的思考方" class="headerlink" title="引用计数的思考方"></a>引用计数的思考方</h5><ol>
<li>自己生成的对象，自己持有</li>
<li>非自己生成的对象，自己也能持有</li>
<li>不再需要自己持有的对象时释放</li>
<li>非自己持有的对象无法释放<br>| 对象操作 | OC方法 |<br>| – | :–: |<br>| 生成并持有对象 | alloc/new/copy/mutableCopy… |<br>| 持有对象 | retain |<br>| 释放对象 | release |<br>| 废弃对象 | dealloc |<br>以上述方法开头的方法名拥有相似的对象操作含义</li>
</ol>
<h5 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h5><p>当我们要使用某个方法生成一个对象返回给调用者时，该怎么处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-(id)allocObject &#123;</span><br><span class="line">    id obj = [NSObject new];</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想上个例子中展示，生成obj的时候使用new就是被本身持有的，但是当大括号结束之后这个obj的生命周期就被释放掉了，所以这中间少了重要的一步<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj autorelease];//取得对象存在，但本身不持有</span><br></pre></td></tr></table></figure></p>
<p>这个时候这个obj对象不会立即释放，而是被注册到autoreleasePool中，当pool结束时自动调用release方法释放对象。<br><strong><em>autorelease的具体使用方法如下</em></strong></p>
<ol>
<li>生成并持有NSAutoreleasePool对象</li>
<li>调用已分配对象的autorelease实例方法</li>
<li>废弃NSAutoreleasePool对象</li>
</ol>
<h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><h5 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h5><ol>
<li>__strong 修饰符:表示对对象的强引用，id类型和对象类型所有权修饰符默认,所以声明时不需要加</li>
<li><strong>weak修饰符：\</strong>\strong无法解决对象之间相互引用导致的循环引用问题，使用weak修饰符打破循环</li>
<li>__unsafe_unretained修饰符</li>
<li>__autoreleasing修饰符：该修饰符一般不显示的出现在代码中，会通过@autoreleasepool的方式隐式的出现</li>
</ol>
<h5 id="内存管理规则总结"><a href="#内存管理规则总结" class="headerlink" title="内存管理规则总结"></a>内存管理规则总结</h5><ol>
<li>不能显示的调用dealloc方法</li>
<li>使用@autorelreasepool块替代NSAutoreleasePool</li>
<li>不能使用区域（NSZone)</li>
<li>对象型变量不能为C语言结构体类型</li>
<li>显示转换id和void*（__bridge转换）</li>
</ol>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><table>
<thead>
<tr>
<th>属性声明</th>
<th style="text-align:center">所有权修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td style="text-align:center">__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td style="text-align:center">__strong</td>
</tr>
<tr>
<td>retain</td>
<td style="text-align:center">__strong</td>
</tr>
<tr>
<td>strong</td>
<td style="text-align:center">__strong</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td style="text-align:center">unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td style="text-align:center">__weak</td>
</tr>
</tbody>
</table>
<h4 id="ARC实现"><a href="#ARC实现" class="headerlink" title="ARC实现"></a>ARC实现</h4><h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h5><p>使用__strong修饰符需要注意一个点，就是当持有一个不是自己生成的对象，并将该对象作为返回值时，编译器会转化出一个方法<strong><em>objc_autoreleaseReturnValue(obj)</em></strong>这个方法的作用与objc_autorelease很相似，但又有点不一样，它会检查使用该函数的调用方的执行命令列表，如果方法或函数中再调用该方法后紧接着调用<strong><em>objc_retainAutoreleaseReturnValue</em></strong>方法，那就不会将obj注册到autoreleasepool中，而是直接返回给函数的调用方。<br><strong><em>可以不降obj注册到autoreleasepool中，而是直接传递，这一过程达到最优化（objc4的493.9版本中，只能在OS X 64位环境下）</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">    id obj = objc_msgSend(NSMutableArray, @selector(alloc));</span><br><span class="line">    objc_msgSend(obj, @selector(init));</span><br><span class="line">    return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h5><ol>
<li>若有__weak修饰符修饰的变量所引用的对象被废弃，则将nil赋值给该变量</li>
<li>使用__weak修饰符的变量，即是使用注册到autoreleasepool中的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id __weak obj1 = obj;</span><br><span class="line">&#125;</span><br><span class="line">编译器转换</span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1,obj);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>__weak修饰的对象被释放时的流程</p>
<ol>
<li>objc_release </li>
<li>因为引用计数为0所以执行dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating<br>第6步函数动作可以如下解析</li>
<li>从weak表中获取废弃对象的地址为键值得记录</li>
<li>将包含在记录中的所有附在__weak修饰符变量的地址，赋值为nil</li>
<li>从weak表中删除该记录</li>
<li><p>从引用计数表中删除废弃对象的地址为键值得记录<br>使用附有__weak修饰符变量的情形下，怎加了对objc_loadWeakRetained函数和objc_autorelease函数的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1,obj);</span><br><span class="line">id tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line">NSLog(@&quot;%@&quot;,tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>objc_loadWeakRetained函数取出附有__weak修饰符变量所引用的对象并retain</p>
</li>
<li>objc_autorelease函数将对象注册到autoreleasepool中</li>
</ol>
<p><strong><em>ps（当allowsWeakReference/retainWeakReference实例方法返回NO的时候，不能使用__weak修饰符,会导致程序crash）</em></strong></p>
<h5 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h5><p>这里需要关注的就是前面提到的成对出现的函数，不注册到autoreleasepool最优内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *array = [NSMutableArray array];</span><br></pre></td></tr></table></figure></p>
<h3 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h3><p>Blocks就是带有自动变量的匿名函数。</p>
<h4 id="Blocks结构体"><a href="#Blocks结构体" class="headerlink" title="Blocks结构体"></a>Blocks结构体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123; //命名规则为：main函数中的第几个block，此处为第一个</span><br><span class="line">    struct __block_impl impl; </span><br><span class="line">    struct __main_block_desc_0* Desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __block_impl &#123;</span><br><span class="line">    void *isa;//block类型指针</span><br><span class="line">    int Flags;//标志位</span><br><span class="line">    int Reserved;//保留字段</span><br><span class="line">    void *FuncPtr;//函数指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct __main_block_desc_0 &#123;</span><br><span class="line">    unsigned long reserved;//保留字段</span><br><span class="line">    unsigned long Block_size;//大小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">看看初始化这些结构体的构造函数</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = des;</span><br><span class="line">&#125;</span><br><span class="line">构造函数调用如下</span><br><span class="line">void (*blk)(void) = (void (*)(void))&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">去掉转换部分简写如下</span><br><span class="line">struct __main_block_impl_0 temp = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);</span><br><span class="line">struct __main_block_impl_0 *blk = &amp;temp;</span><br><span class="line">第一个参数为Block语法转换的C语言函数指针。第二个参数是作为静态全局变量初始化的__main_block_desc_0结构体实例指针</span><br><span class="line">static struct __main_block_desc_0 __main_block_desc_0_DATA = &#123;</span><br><span class="line">    0,</span><br><span class="line">    sizeof(struct __main_block_impl_0)</span><br><span class="line">&#125;;</span><br><span class="line">这个时候展开_block_impl结构体会被如下初始化</span><br><span class="line">isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">Flags = 0;</span><br><span class="line">Reserved = 0;</span><br><span class="line">FuncPtr = __main_block_func_0;</span><br><span class="line">Desc = &amp;__main_block_desc_0_DATA;</span><br><span class="line"></span><br><span class="line">最后再使用该block时 blk() </span><br><span class="line">((void (*)(struct __block_impl *))((struct __block_impl *)block)-&gt;FuncPtr)((struct __block_impl *)blk);</span><br><span class="line">转换如下</span><br><span class="line">（*blk-&gt;impl.FuncPtr)(blk);</span><br></pre></td></tr></table></figure>
<h4 id="截获自动变量"><a href="#截获自动变量" class="headerlink" title="截获自动变量"></a>截获自动变量</h4><p>在block中使用外部变量时，如果在内部对这个外部变量进行赋值，该源代码会产生编译错误。若想在block语法中赋值给block语法外声明的自动变量，需要在该变量上附加__block说明符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int val = 0;</span><br><span class="line">void (^blk)(void) = ^&#123;val = 1;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>上述代码会出现编译错误，但是如果是使用OC对象则没有问题，当然对OC对象直接赋值也是会直接导致编译错误</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id array = [NSMutableArray alloc] init]];</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    id obj = [NSObject alloc] init]];</span><br><span class="line">   [array addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>还有一个需要注意的点是在block中使用截获的C语言数组也是会出现编译错误，因为截获自动变量的方法并没有实现对C语言数组的截获，这个时候需要使用指针解决问题</em></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char text[] = &quot;hello&quot;; //编译出错 -&gt; const char *text = &quot;hello&quot;;</span><br><span class="line">void (^blk)(void) = ^&#123;</span><br><span class="line">    printf(&quot;%c\n&quot;,text[2]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当给外部变量附加了__block说明符，那么源码转换代码会急剧增加，会将外部变量转换为一个结构体实例,该结构体声明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct __Block_byref_val_0&#123;</span><br><span class="line">    void *__isa;</span><br><span class="line">    __Block_byref_val_0 *__forwarding;</span><br><span class="line">    int __flags;</span><br><span class="line">    int __size;</span><br><span class="line">    int val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里我们要重点了解一下这个forwarding成员变量，<strong>Block_byref_val_0结构体实例成员变量 </strong>forwarding持有执行该实例自身的指针，val-&gt; __forwarding -&gt; val</p>
<h4 id="Block存储域"><a href="#Block存储域" class="headerlink" title="Block存储域"></a>Block存储域</h4><table>
<thead>
<tr>
<th>名称</th>
<th style="text-align:center">实质</th>
</tr>
</thead>
<tbody>
<tr>
<td>Block</td>
<td style="text-align:center">栈上Block的结构体实例</td>
</tr>
<tr>
<td>__block变量</td>
<td style="text-align:center">栈上 __block变量的结构体实例</td>
</tr>
</tbody>
</table>
<p>由于Block也是Objective-C对象，将Block当做OC对象来看时，该Block的类为_NSConcereStackBlock，相似的如</p>
<ol>
<li>_NSConcreteStackBlock  //栈上的block，存储在栈上</li>
<li>_NSConcreteGlobalBlock //全局的block，存储在数据区域.data区中</li>
<li>_NSConcreteMallocBlock //堆上的block，由malloc函数分配的堆中</li>
</ol>
<p>在记叙全局变量的地方使用block语法生成的是Global block；还有一种情况下将block用结构体实例设置在程序的数据区域，那就是在函数内使用Block语法，但是只要Block不截获自动变量。<br>除上述之外的Block语法生成的Block都是设置在栈上的，那么什么时候block会设置在堆上？</p>
<p>配置在全局变量上的Block，从变量作用域外也可以通过指针安全的使用，但设置在栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，由于<strong>block变量也配置在栈上，同样地，如果其所属变量作用域结束，则该 </strong>block变量也会被废弃。<br>Blocks提供了将Block和<strong>block变量从栈上复制到堆上的方法来解决这个问题，将配置在栈上的block赋值到堆上，这样即使block语法记叙的变量作用域结束，堆上的block还可以继续存在。<br>复制到堆上的Block将_NSConcreteMallocBlock类对象写入Block结构体的isa指针，而</strong>block变量用结构体成员变量 <strong>forwarding可以实现无论 </strong>block变量时配置在栈上或者堆上都能正确的访问 __block变量。何时copy是在ARC情况下由编译器自行判断，但是当编译器无法判断时了？<br><strong><em>向方法或函数的参数中传递Block时</em></strong><br>这个时候就需要我们手动的去对block进行copy操作，例如像NSArray中的initWithObjects实例方法上传递block。不管是什么类型的block，复制之后都不会引起任何问题，所以在不确定的时候调用copy方法可以解决很多问题</p>
<h4 id="block变量存储域"><a href="#block变量存储域" class="headerlink" title="__block变量存储域"></a>__block变量存储域</h4><table>
<thead>
<tr>
<th>__block变量的配置存储域</th>
<th style="text-align:center">Block从栈复制到堆得影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈</td>
<td style="text-align:center">从栈复制到堆并被Block持有</td>
</tr>
<tr>
<td>堆</td>
<td style="text-align:center">被Block持有</td>
</tr>
</tbody>
</table>
<p>无论<strong>block配置在什么地方，通过</strong>forwarding持有<strong>block变量，当block释放时，</strong>block也会随之释放。</p>
<h4 id="截获对象"><a href="#截获对象" class="headerlink" title="截获对象"></a>截获对象</h4><p>存储在栈上的block当它的变量作用域结束时，那么当中截取的<strong>block自动变量也随之释放，所以在外部调用block时可能会引起crash，因为只有调用_Block_copy函数才能持有截获的附有</strong>strong修饰符的变量，<strong><em>因此，block中使用对象类型自动变量时，除以下情形外，推荐调用copy方法</em></strong></p>
<ol>
<li>Block作为函数返回值</li>
<li>将Block赋值给类的附有__strong修饰符的id类型或者Block类型的成员变量</li>
<li>向方法名中含有usingBlock的cocoa框架方法或GCD的API中传递block时</li>
</ol>
<h4 id="block变量和对象"><a href="#block变量和对象" class="headerlink" title="__block变量和对象"></a>__block变量和对象</h4><p>上面提到要持有截获的附有<strong>strong修饰符的变量，需要调用copy方法，还有一种方法实现就是在前面添加</strong>block说明符也同样可以实现。如果Block中使用<strong>weak修饰符又会出现什么情况呢？<br>根据前面的内存管理相关方法猜想得到使用</strong>weak修饰符变量时，可能不会导致crash，但是该变量应该会被置为nil。<br>还有一个需要注意的地方当obj同时指定<strong>block说明符和</strong>autoreleasings修饰符时会导致编译错误</p>
<h4 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h4><p>这个点应该是开发中遇到Block最大的问题了；若果在block中使用附有<strong>strong修饰符的对象类型自动变量，那么当Block从栈复制到堆上时，该对象被Block持有，如果该变量也持有了block变量，那么就很容易产生循环引用。<br>为了避免循环引用，我们可以声明</strong>weak修饰符的变量，并将原变量赋值给该变量，同样的在block内部最好使用<strong>strong修饰符来接收之前使用</strong>weak修饰的变量，这样可以防止变量被释放时引起的crash；另外我们还可以使用<strong>block变量来避免循环引用问题，但是使用</strong>block来解决循环引用时，若果不执行该block则会有循环引用并引起内存泄漏，因为该情况下<strong>block变量即持有block也持有了对象，所以不执行block则对象永远无法执行dealloc方法，只有执行了block，</strong>block变量被赋值为nil,才可以正常执行程序</p>
<h3 id="委托代理"><a href="#委托代理" class="headerlink" title="委托代理"></a>委托代理</h3><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><ol>
<li>协议：定义代理和委托的共同接口</li>
<li>委托方：根据指定的协议，委托代理去完成时限指定接口</li>
<li>代理方：根据指定的协议，实现委托需要实现的接口</li>
</ol>
<h5 id="weak修饰符-1"><a href="#weak修饰符-1" class="headerlink" title="weak修饰符"></a>weak修饰符</h5><p>代理属性使用weak修饰符修饰，目的是为了避免循环引用；例如tableVC中，vc强引用tableV，设置代理时，都是让vc成为代理，这样tableV又强引用了tableVC。</p>
<h5 id="代理的使用"><a href="#代理的使用" class="headerlink" title="代理的使用"></a>代理的使用</h5><p>声明的方法不做赘述，使用时需要注意的是判断VC有没有遵循协议设置代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(function)]) &#123;</span><br><span class="line">    [self.delegate respondsToSelector:@selector(function)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="代理总结"><a href="#代理总结" class="headerlink" title="代理总结"></a>代理总结</h5><ol>
<li>具有良好的扩展性</li>
<li>有利于代码的封装</li>
<li>代理更有利于对于代码的阅读，相比于block</li>
</ol>
<h4 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@interface NSProxy &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSProxy是一个抽象基类，它为一些表现的像是其他对象替身或者并不存在的对象定义API。一般的，发送给代理的消息被转发给一个真实的对象或者代理本身引起加载一个真实的对象。NSProxy的基类可以被用来透明的转发消息或者耗费巨大的对象的lazy初始化。<br>NSProxy实现了包括NSObject协议在内所需的基础方法，但作为一个抽象类它本身不提供初始化方法，所以使用时必须提供一个初始化方法的子类，并且重载 <strong><em>forwardInvocation:</em></strong> 方法和 <strong><em>methodSignatureForSelector:</em></strong> 方法来处理自己没有实现的消息。</p>
<h4 id="NSProxy的组件化"><a href="#NSProxy的组件化" class="headerlink" title="NSProxy的组件化"></a>NSProxy的组件化</h4><p>大的项目都使用组件化开发，NSProxy可以作为delegate回调方式来解耦项目；OC项目大多集成了YYKit，我们可以使用YYTextWeakProxy来当做中间件，代理方以路由形式将YYTextWeakProxy的实例对象以delegate为参数传递给委托方，在委托方定义协议需要遵循的方法，在合适的时间调用，代理方在实现此委托方法就可以成功的接收到回调消息已达到解耦的目的，同时也可以此来实现多继承的效果。</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><h5 id="Dispatch-Queue-API"><a href="#Dispatch-Queue-API" class="headerlink" title="Dispatch Queue API"></a>Dispatch Queue API</h5><h6 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h6><table>
<thead>
<tr>
<th>Dispatch Queue种类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial Dispatch Queue</td>
<td>等待现在执行中处理结束</td>
</tr>
<tr>
<td>Concurrent Dispatch Queue</td>
<td>不等待…</td>
</tr>
</tbody>
</table>
<h6 id="dispatch-queue-create"><a href="#dispatch-queue-create" class="headerlink" title="dispatch_queue_create"></a>dispatch_queue_create</h6><p>创建Disaptch Queue的方法，该方法有两个参数，第一个指定queue name，第二个参数若指定为NULL则生成Serial Queue，否则为Concurrent Queue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = disaptch_queue_create(&quot;com.example.zhuhuang.myQueue&quot;,NULL);</span><br></pre></td></tr></table></figure></p>
<h6 id="Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue/Global Dispatch Queue"></a>Main Dispatch Queue/Global Dispatch Queue</h6><p>除了通过dispatch_queue_create去创建队列，我们还可以获取系统提供的标准队列。<br>Main Queue就是主线程中的queue，只有1个，自然也是Serial Queue;而Global有优先级高低之分</p>
<h6 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h6><p>通过dispatch_queue_create生成的队列，都是使用默认优先级相同执行优先级的线程。而变更优先级就需要用到dispatch_set_target_queue函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.zhuhuang&quot;,NULL);</span><br><span class="line">dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);</span><br><span class="line">dispatch_set_target_queue(queue,globalQueue);</span><br></pre></td></tr></table></figure></p>
<p>将第二个Dispatch Queue的优先级指定给第一个Dispatch Queue，不可将系统的Dispatch Queue作为第一个参数</p>
<h6 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,3ull * NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(),^&#123;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>值得注意的是dispatch_after不是在指定时间后处理，而是在指定时间后追加到Dispatch Queue中处理</p>
<h6 id="Dispatch-Group"><a href="#Dispatch-Group" class="headerlink" title="Dispatch Group"></a>Dispatch Group</h6><p>在追加到Disaptch Queue种的处理全部结束后再执行某个处理，这种只使用一个Serial Disaptch Queue就可以处理；但是如果使用了Concurrent Disaptch Queue或者多个Dispatch Queue时，就会变得复杂起来；在这种情况下就需要使用Dispatch Group<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = disaptch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</span><br><span class="line">dispatch_group_t group = disaptch_group_create();</span><br><span class="line">dispatch_group_async(group,queue,^&#123;...&#125;);</span><br><span class="line">dispatch_group_async(group,queue,^&#123;...&#125;);</span><br><span class="line">dispatch_group_async(group,queue,^&#123;...&#125;);</span><br><span class="line">dispatch_group_notify(group,dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class="line">dispatch_release(group);</span><br></pre></td></tr></table></figure></p>
<h6 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h6><p>在访问数据库或文件时，通过多线程操作时经常会出现数据竞争情况，导致获得的结果有误差，严重的可能导致crash。写入处理不可与其他写入处理以及包含读取处理的其他处理并行执行，但是如果读取处理是可以并行处理并不产生问题的。<br>为了高效的进行访问，读取处理追加到Concurrent Dispatch Queue中，写入处理在任意一个没有读取处理的状态下，卓驾到Serial Dispatch Queue中就可以了。<br>这种情况下 我们有了一个更实用的API，dispatch_barrier_async。<br><strong><em>不管是同步栅栏还是异步栅栏都必须与自定义的Concurrent Dispatch Queue配合使用，不然无法起到栅栏的效果，同步栅栏与dispatch_get_main_queue()一起使用会造成死锁</em></strong></p>
<h6 id="disaptch-sync"><a href="#disaptch-sync" class="headerlink" title="disaptch_sync"></a>disaptch_sync</h6><h6 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h6><p>该函数可能是我们在平时用的较多的GCD的Api之一，是disaptch_sync与Dispatch Group的关联API。按指定的次数将指定的Block追加到指定的Dispatch Queue中，并等待处理全部结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_apply(10, queue, ^(size_t index) &#123;</span><br><span class="line">    NSLog(@&quot;%zu&quot;,index);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h6 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h6><h6 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h6><p>当并行执行的处理更新数据时，会产生数据竞争的问题,严重时还会导致crash。在这里通过Serial Disaptch Queue和dispatch_barrier_async函数可以避免类似问题，但是我们还需要更细力度的控制<br>Disaptch Semaphore是持有计数的信号，该计数是多线程编程中的计数类型信号。计数为0时等待，计数为1或大于1的时，减去1而不等待。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW,1ull * NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_semaphore_wait(semaphore,time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">    //这时可以执行需要进行排他控制的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h6><p>dispatch_once函数式保证在应用程序执行中只执行一次指定处理的API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static dispatch_once_t once;</span><br><span class="line">dispatch_once(&amp;once,^&#123;</span><br><span class="line">    // 单例的初始化</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h6 id="Dispatch-I-O"><a href="#Dispatch-I-O" class="headerlink" title="Dispatch I/O"></a>Dispatch I/O</h6><p>在读取较大文件时，如果将文件分成合适的大小并使用Global Dispatch Queue并列读取的话，应该会比一般的读取速度要快很多。现在输入/输出硬件已经可以做到一次使用多个线程更快的并列读取了，Disaptch I/O和Disaptch Data就是用来实现这一功能的。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>NSOperation和NSOperationQueue是苹果提供的一套多线程解决方案。实际上是基于GCD完全面向对象的一层封装；但相比较于GCD更简单易用，代码可读性也更高。</p>
<h5 id="Why-NSOperation？"><a href="#Why-NSOperation？" class="headerlink" title="Why NSOperation？"></a>Why NSOperation？</h5><ol>
<li>可添加完成的代码块，在操作完成后执行</li>
<li>添加操作之间的依赖关系，方便管理执行顺序</li>
<li>设定操作执行的优先级</li>
<li>可以方便的取消某个操作</li>
<li>使用KVO观察对操作的执行状态的更改：isExecuteing、isFinished、isCancelled</li>
</ol>
<h5 id="NSOperation操作和操作队列"><a href="#NSOperation操作和操作队列" class="headerlink" title="NSOperation操作和操作队列"></a>NSOperation操作和操作队列</h5><p>操作（NSOperation）：</p>
<ol>
<li>执行操作，即在线程中执行的某段代码</li>
<li>在GCD中是放在Block中，在NSOperation中，我们使用NSOperation子类<strong><em>NSInvocationOperation、NSBlockOperation</em></strong>，或者自定义的子类来封装操作<br>操作队列（Operation Queue）：</li>
<li>存放操作的队列。不同于GCD的调度队列FIFO（先进先出）原则。NSOperationQueue对于添加到队列中的操作，先进入就绪状态（取决于操作之间的依赖关系），然后就绪的操作开始执行顺序（非结束执行顺序）由操作之间相对优先级决定（优先级是操作对象自身的属性）。</li>
<li>操作队列通过设置最大并发数（maxConcurrentOperationCount）来控制并发、串行</li>
<li>NSOperationQueue为我们提供两种不同类型的队列：主队列和自定义队列（主队列运行在主线程上，自定义队列在后台执行）。</li>
</ol>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p>NSThread是苹果官方提供的面向对象操作线程的技术，简单方便；同时NSThread是封装成都最小最轻量级的，使用更灵活，但是要手动管理线程的生命周期、线程同步和线程加锁等，开销较大。</p>
<h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><ol>
<li>临界区:指的是对一块公共资源访问的代码</li>
<li>自旋锁:用于多线程同步的一种锁，线程反复检查锁变量是否可用。<strong><em>OSSPinLock(不再安全),os_unfair_lock(苹果官方替代方案)</em></strong></li>
<li>互斥锁:用于多线程编程中，防止两条线程同时对一公共资源进行读写的机制。 <strong><em>NSLock,pthread_mutex,@synchronized</em></strong></li>
<li>读写锁:计算机程序的并发控制的同步机制，也叫“共享-互斥锁”。<strong><em>pthread_rwlock</em></strong></li>
<li>信号量:更高级别的同步机制，互斥锁可以看做是semaphore在仅取值0/1的特例。<strong><em>dispatch_semaphore</em></strong></li>
<li>条件锁:条件变量，当进程的某些资源要求不满足时就休眠。<strong><em>NSCondition,NSConditionLock</em></strong></li>
<li>递归锁:互斥锁的一种，在同一个线程中要多次获得一个锁，只能使用递归锁，不然会造成死锁<strong><em>不提倡使用递归锁</em></strong>。<strong><em>NSRecursiveLock,pthread_mutex</em></strong></li>
</ol>
<p><strong><em>死锁：通常指两个线程由于某些原因处于相互等待而都不能完成的</em></strong></p>
<h3 id="KVC-KVO"><a href="#KVC-KVO" class="headerlink" title="KVC-KVO"></a>KVC-KVO</h3><h4 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h4><p>KVC(key-value coding)键值编码，开发中允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值，而不需要调用明确的存取方法（在运行时动态的访问和修改对象的属性）。很多高级的iOS开发技巧都是通过这一特性来实现的。<br>KVC的定义都是通过对NSObject的扩展来实现的，OC中有个显示的NSKeyValueCoding类别名，所以对于所有继承了NSObject的类型，都能使用KVC。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></p>
<h5 id="KVC底层原理"><a href="#KVC底层原理" class="headerlink" title="KVC底层原理"></a>KVC底层原理</h5><ol>
<li>寻找该属性有没有设置setter方法，有就直接赋值</li>
<li>寻找有没有该属性带下划线的成员属性有就直接赋值（类方法accessInstanceVairablesDirectly返回值为YES的情况下才可以执行该步骤）</li>
<li>寻找有没有该属性的成员属性有就直接赋值（没找到调用setValue:forUnderfinedKey:)</li>
</ol>
<h5 id="KVC运用场景"><a href="#KVC运用场景" class="headerlink" title="KVC运用场景"></a>KVC运用场景</h5><ol>
<li>动态的取值和塞值</li>
<li>访问修改私有变量（iOS13以后可能会导致crash）</li>
<li>用于model的转换</li>
<li>修改一些控件内部属性（同2）</li>
<li>操作集合</li>
<li>实现KVO</li>
</ol>
<h5 id="KVC异常处理"><a href="#KVC异常处理" class="headerlink" title="KVC异常处理"></a>KVC异常处理</h5><p>根据KVC的搜索规则，没有搜到对应的key或者keyPath，则会调用对应的异常方法。默认实现的异常方法会在异常时抛出一个NSUndefinedKeyException的异常，并且Crash。<br>我们可以通过重写以下方法，根据业务需求合理的处理KVC导致的异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br></pre></td></tr></table></figure></p>
<p>另外当通过KVC给某个非对象的属性赋值为nil时，此时KVC会调用属性对象的setNilValueForKey:方法，并抛出NSInvalidArgumentException的异常，导致Crash。<br>该情况下可以通过重写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNilValueForKey:(NSString *)key &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>KVO（key-value Observing）键值观察，是苹果提供的一套事件通知机制。允许对象监听另一个对象特定属性的变化，并在改变时接收到事件。<br>KVO和NSNotificationCenter都是iOS中观察者模式的一种实现，区别在于，相对于观察者和观察者之间的关系，KVO是一对一的，KVO对被监听对象无侵入性。<br>KVO可以监听单个属性的变化，也可以监听集合对象的变化。通过KVC的mutableArrayValueForKey:等方法获得代理对象，当代理对象内部对象发生改变时，会回调KVO的监听方法（NSArray，NSSet)</p>
<h5 id="KVO底层原理"><a href="#KVO底层原理" class="headerlink" title="KVO底层原理"></a>KVO底层原理</h5><p>KVO是通过isa-swizzling技术实现的。在运行时根据原类A创建一个中间类NSKVONotifying_A，并将被观察的类A的isa指针指向中间类NSKVONotifying_A，然后重写中间类的set方法，在set方法中对被观察的属性值储存并发出通知，同时也在其中调用父类A的set方法。（苹果重写了中间类的class方法 返回原类的class，这么做是为了隐藏中间类，屏蔽内部实现）</p>
<h3 id="NSRunloop"><a href="#NSRunloop" class="headerlink" title="NSRunloop"></a>NSRunloop</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">functino loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quit);</span><br><span class="line">&#125;  Event Loop</span><br></pre></td></tr></table></figure>
<p>一般来说，一个线程一次只能执行一个任务，执行完成后线程就会退出。这种模型通常被称为EventLoop。实现这种模型的关键点在于如何管理消息、事件，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>所以RunLoop实际上是一个对象，这个对象管理了需要它处理的事件和消息，并提供一个入口函数来执行上面的EventLoop逻辑。线程执行这个函数后，就会一直处于函数内部的“接受消息-&gt;等待-&gt;处理”的循环中，知道这个循环结束，函数返回。<br>iOS/OSX系统中，提供了两个这样的对象：NSRunLoop和CFRunLoopRef。<br>CFRunLoopRef是在CoreFoundation框架内的，它提供了纯C函数的API，所有这些API都是线程安全的。<br>NSRunLoop是基于CFRunLoopRef的封装，提供了面向对象的API，但这些API不是线程安全的。</p>
<h4 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h4><p>苹果不允许直接创建RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain()和CFRunLoopGetCurrent()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">    &#125;</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread);</span><br><span class="line">    if (!loop)&#123;</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic,thread,loop);</span><br><span class="line">        _CFSetTSD(...,thread,loop);</span><br><span class="line">    &#125;</span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码不难看出，线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary中。线程刚创建时并没有RunLoop，如果你不主动获取，那它一直都不会有。RunLoop的创建是发生在第一次获取时，RunLoop的销毁时发生在线程结束时。你只能在一个线程内部获取其RunLoop（主线程除外）</p>
<h4 id="RunLoop对外接口"><a href="#RunLoop对外接口" class="headerlink" title="RunLoop对外接口"></a>RunLoop对外接口</h4><ol>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef<br>意思即使字面意思，其中CFRunLoopModeRef并不对外暴露，而是通过CFRunLoopRef的接口进行封装。对应关系如下：<br>一个RunLoop包含若干个Mode，每个Mode又包含Source、Timer、Observer。每次调用RunLoop时，只能指定其中一个Mode，这个Mode称为CurrentMode。切换Mode时需要退出loop，再重新指定一个Mode进入。这样做的原因是为了分隔开不同组的Source、Timer、Observer，让其不互相影响。<br>CFRunLoopSourceRef：事件产生的地方，包含Source0、Source1。</li>
<li>Source0：只包含一个回调（函数指针），不能主动触发事件。使用时，需要先调用CFRunLoopSourceSignal(source)，将这个source标记为待处理，然后手动调用CFRunLoopWakeUp(runloop)来唤醒RunLoop，让其处理这个事件</li>
<li>Source1：包含一个mach_port和一个回调，备用于通过内核和其他线程相互发送消息，能主动唤醒RunLoop<br>CFRunLoopTimerRef是基于事件的触发器，它和NSTimer可以混用。其包含一个事件长度和一个回调。当其被加入到RunLoop时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒执行那个回调。<br>CFRunLoopRefObserver是观察者，每个Observer都包含一个回调，当RunLoop状态发生改变时，观察者就能通过回调接受到这个改变。可以观测的时间点如下：</li>
<li>kCFRunLoopEntry //即将进入loop</li>
<li>kCFRunLoopBeforeTimers //即将进入Timer</li>
<li>kCFRunLoopBeforeSources //即将进入Source</li>
<li>kCFRunLoopBeforeWaiting //即将进入休眠</li>
<li>kCFRunLoopAfterWaiting //刚从休眠中唤醒</li>
<li>kCFRunLoopExit //即将退出loop<br>上面的Timer、Source、Observer统称为mode item，一个item可以被同时加入多个mode。但一个item被重复加入同一个mode时无效。如果一个mode中一个item都没有，则RunLoop会直接退出，不进入循环。<br>因为RunLoop在一个时间只能执行一个Mode，所以苹果引入了一个“CommonModes”的概念。一个Mode可以将自己标记为“Common”属性（通过设置ModeName添加到RunLoop的“CommonModes”中）。每当RunLoop的内容发生改变时，RunLoop都会自动将_commonModeItems里的Source/Observer/Timer同步到具有“common”标记的所有Mode里。<br>常见的场景就是在ScrollView中添加一个NSTimer，当页面滑动时NSTimer将失效，滑动结束后NSTimer将继续作用。原因就是ScrollView滑动的状态是被标记在UITrackingRunLoopMode中，而App平时的状态是KCFRunLoopDefaultMode，当Timer被加入到DefaultMode时，页面滑动会切换Mode，timer就不会回调了。想Timer起作用，就需要将Timer分别加入到两种不同的Mode或者将Timer加入到CommonModes中。</li>
</ol>
<h4 id="RunLoop的底层实现"><a href="#RunLoop的底层实现" class="headerlink" title="RunLoop的底层实现"></a>RunLoop的底层实现</h4><h4 id="RunLoop的应用场景"><a href="#RunLoop的应用场景" class="headerlink" title="RunLoop的应用场景"></a>RunLoop的应用场景</h4><h5 id="AutoReleasePool"><a href="#AutoReleasePool" class="headerlink" title="AutoReleasePool"></a>AutoReleasePool</h5><p>App启动后，主线程在RunLoop里注册了两个Observer，第一个监听事件是Entry，其内回调会调用_objc_autoreleasePoolPush()创建自动释放池，而且优先级最高，保证创建释放池在其他所有回调之前；第二个监听两个事件：BeforeWaiting时调用_objc_autoreoleasePoolPop()和_objc_autoreleasePoolPush()来释放旧的并创建新的自动释放池，Exit时调用_objc_autoreleasePoolPop(),且这个回调优先级最低，保证在所有回调之后。</p>
<h5 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h5><p>苹果注册了一个Source1（基于mach port）用来接收系统事件，其回调函数为__IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件发生后，首先由IOKit.framework生成一个IOHIDEvent事件并有SpringBoard接收。随后用mach port转发给需要的App进程，苹果注册的Source1在这个时候就会触发回调，并调用_UIApplicationHandleEventQueue()进行应用内部的分发。</p>
<h5 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h5><p>当_UIApplicationHandleEventQueue()识别了一个手势，会先调用Cancel将当前的touchesBegin/Move/End系列回调打断。随后将UIGestureRecognizer标记为待处理。<br>苹果注册了一个Observer监测BeforeWaiting事件，这个Observer回调函数是_UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行回调</p>
<h5 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h5><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><p>NSTimer注册到RunLoop后，RunLoop会为其重复的时间点注册号事件。RunLoop为了节省资源，并不会非常准确的在这个时间点回调Timer。Timer有个属性叫Tolerance，标识了当时间点到后，容许最大的误差。如果某个点错过了，例如执行一个很长的任务，那该时间点的回调也会被跳过，不会延后执行。<br>CADisplayLink是一个和屏幕刷新率一致的定时器。如果在两次刷新间执行了一个长任务，那其中就会有一帧被跳过去（和NSTime相似），造成界面卡顿的感觉。</p>
<h5 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h5><h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>指将数据类型的确定由编译时推迟到运行时，是一套比较底层的纯C语言API主要用于以下几个地方，</p>
<ol>
<li>给系统分类添加属性、方法</li>
<li>交换方法</li>
<li>获取对象的私有属性</li>
<li>字典模型转换</li>
<li>KVC、KVO</li>
<li>编码、解码</li>
<li>获取类名</li>
<li>block</li>
<li>…<h4 id="Runtime数据结构分析"><a href="#Runtime数据结构分析" class="headerlink" title="Runtime数据结构分析"></a>Runtime数据结构分析</h4>OC中，类、对象和方法都是结构体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Class是一个objc_class结构类型的指针，id是一个objc_object结构类型的指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;//Class类型的指针，实例对象的isa指向Class，Class的isa指向metaClass</span><br><span class="line">    Class super_class</span><br><span class="line">    const char *name</span><br><span class="line">    long version</span><br><span class="line">    long info</span><br><span class="line">    long instance_size //类实例变量大小</span><br><span class="line">    struct objc_ivar_list *ivars //成员变量链表</span><br><span class="line">    struct objc_method_list **methodLests //方法链表</span><br><span class="line">    struct objc_cache *cache //指向最近调用的方法，对于方法调用的优化机制</span><br><span class="line">    struct obj_protocol_list //协议链表</span><br><span class="line">&#125;；</span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete</span><br><span class="line">    int method_count</span><br><span class="line">    struct objc_method method_list[1]</span><br><span class="line">&#125;</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name;</span><br><span class="line">    char *method_types</span><br><span class="line">    IMP method_imp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Runtime消息机制"><a href="#Runtime消息机制" class="headerlink" title="Runtime消息机制"></a>Runtime消息机制</h4><p>类的消息发送的核心方法就是objc_msgSend，通过objc_msgSend方法我们可以知道接收方法对象，查找对象上对应的objc_method，以及传递参数给这个类，最后将返回值传递回来。</p>
<ol>
<li>消息发送给对象时，消息传递函数遵循对象的isa指针指向类结构的指针，在该结构中它查询结构体变量methodLists中的方法SEL</li>
<li>如在isa指向的类结构体中找不到SEL，objc_msgSend会沿着指向superClass指针并再次查找SEL</li>
<li>如连续失败直到NSObject类，则会进行消息转发</li>
<li>如果找到SEL，该函数就会调用methodLists的方法并将接收对象的指针传给它<br>这中间有个概念叫<strong><em>加速消息转发</em></strong><br>OC中的类基本都有继承关系，这就导致methodLists方法较多，查找过程中难免拖累运行速度，所以在Apple在开发的时候加入cache的概念，即缓存。每个类都有一个单独的缓存，它可以包含继承过来的SEL以及在即的自定义SEL，在搜索methodLists之前，消息传递程序会检查接收者对象的缓存cache，如果找到，就不会去搜索methodLists列表。理论上说cache缓存的是一些会再次调用的SEL，所以基本发送过的SEL都会在cache中找到；且cache是动态增长的，会容纳新的消息，知道整个程序中所有调用的SEL运行一遍为止<br><strong><em>规避动态绑定的方法，获取方法地址</em></strong><br>代码正常编译时，需要使用消息传递objc_msgSend才能找到方法的IMP，这中间就有了消息传递的过程，有时候我们不希望调用消息传递，或者节省消息传递的开销，就需要拿到方法的IMP<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void (*setter)(id, SEL, BOOL);</span><br><span class="line">int i;</span><br><span class="line">setter = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(setName:)];</span><br><span class="line">setter(self, @selector(setName:), YES);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong><em>传递给方法实现的前两个参数是接收对象（self）和方法选择器对象（SEL），这些参数是隐藏在方法的语法中了，当方法作为函数被调用时，必须使隐藏的参数显化</em></strong><br>使用methodForSelector可以绕过动态绑定的传递过程，该方法由cocoa运行时提供。</p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>前面提到消息传递过程会沿着继承的类中一直查找methodLists，知道找到对应的SEL，如果找不到会做消息转发。iOS的消息转发机制，可以有效的解决我们在忘记声明方法而导致的crash问题，当然这个点可以在开发阶段就可以解决，在这主要想说的是在运行时动态的去添加接收者中<strong><em>未知</em></strong>方法的实现。</p>
<h5 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel实例方法解析</span><br><span class="line">+ (BOOL)resolveCalssMethod:(SEL)sel类方法解析</span><br></pre></td></tr></table></figure>
<p>当运用消息转发时，首先根据接收对象选择上述两个方法种的一个，返回BOOL类型，告知系统消息是否被处理</p>
<h5 id="后备接受者对象"><a href="#后备接受者对象" class="headerlink" title="后备接受者对象"></a>后备接受者对象</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>当动态方法解析没有处理方法时，系统会让另一个对象B来处理这个方法，如果B能处理该方法，那么消息转发结束，方法被B处理。<strong><em>将未知的SEL作为参数传入，寻找另外对象处理，如果可以处理，返回该对象</em></strong></p>
<h5 id="消息签名"><a href="#消息签名" class="headerlink" title="消息签名"></a>消息签名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation;</span><br></pre></td></tr></table></figure>
<p>当后背接收者也无法处理SEL时，上述两个方法是最后寻找IMP的机会</p>
<ol>
<li>将未知SEL作为参数传入methodSignatureForSelector，在该方法中处理SEL，如果能够处理，返回方法签名让后续forwardInvocation来进行处理</li>
<li>在forwardInvocation中我们可以用很多方法来处理这个方法签名</li>
</ol>
<p>如果通过以上方法都无法处理SEL，则会抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector</span><br></pre></td></tr></table></figure></p>
<p>理论上我们可以重载这个函数保证不抛出异常</p>
<h4 id="Runtime实际应用"><a href="#Runtime实际应用" class="headerlink" title="Runtime实际应用"></a>Runtime实际应用</h4><h5 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h5><p>通过runtime根据key来对应的property属性名称进行赋值。<br><strong><em>class_copyPropertyList获取类中所有的属性</em></strong>ps 通过该方法获取的属性，并不受ARC控制需要手动释放</p>
<h5 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h5><p>解耦开发过程，Router、Mediator</p>
<h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>响应者对象UIResponder，只有继承UIResponder的类，才能处理事件。通过.h文件可以知道UIApplication、UIView、UIViewController等都是继承自UIResponder，可以响应处理对象</p>
<h4 id="事件的分发与传递"><a href="#事件的分发与传递" class="headerlink" title="事件的分发与传递"></a>事件的分发与传递</h4><ol>
<li>当iOS程序发生触摸后系统通过RunLoop的Source触发一个事件，并将事件加入到UIApplication管理的任务队列当中</li>
<li>UIApplication将处于任务队列最前端的事件分发给UIWindow</li>
<li>UIWindow将事件向下分发给UIViewController</li>
<li>UIViewController降任务向下分发给UIView</li>
<li>UIView会判断自身是否可以处理事件，如果不能则寻找能处理的子View</li>
<li>遍历完找不到处理者，则处理者为自己，而自己不能处理则不作响应</li>
</ol>
<h4 id="寻找合适的响应对象"><a href="#寻找合适的响应对象" class="headerlink" title="寻找合适的响应对象"></a>寻找合适的响应对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;//返回本次点击事件最佳View</span><br><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;//判断一个点是否在范围内</span><br></pre></td></tr></table></figure>
<p>事件传递给控件后，就会调用hitTest:withEvent:方法寻找更合适的View，如果是子View则在子View中继续调用该方法，一直遍历下去，直到找到最合适的View或者废弃事件。当父视图的userInteractionEnabled关闭时，return nil，子视图无法继续查找。<br>扩大按钮的响应范围 也可以使用上面方法改进</p>
<h4 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h4><p>响应链是从最合适的view开始传递，处理事件传递给下一个响应者，响应者链的传递方向是事件传递的反方向，若果所有响应者都不处理事件，则时间丢弃。获取下一个响应者方法是UIResponder的nextResponder方法<br>subView -&gt; View -&gt; ViewController -&gt; Window -&gt; Application -&gt; ApplicationDelegate</p>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><ol>
<li>layoutSubviews：初始化不会触发，设置frame时会触发；addSubview、滚动ScrollView、旋转Screen、改变View的大小。</li>
<li>setNeedsLayout：标记为需要重新布局，不立即刷新。当调用layoutSubviews时一定会被调用，并配合layoutIfNeeded立即更新</li>
<li>layoutIfNeeded：如果有需要刷新的标志，则立即调用layoutSubviews进行布局。需要在动画中调用该方法，否则layout的动画无效</li>
<li>setNeedsDisplay</li>
<li>drawRect：用来重绘View的。如果UIView的初始化没有设置大小，导致该方法不被自动调用；在sizeToFit后被系统自动调用；设置contentMode为Redraw时，将在frame设置或更改后自动调用；直接调用setNeedsDisplay时会触发（前提条件是rect不能为0）</li>
<li>sizeThatFits</li>
<li>sizeToFit：自动调用sizeToThatFits，不应该在子类中被重写，需要重写sizeToThatFits，只对自身负责<br>以上为layout中常用的几个方法</li>
</ol>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP属于应用层，是一个简单请求响应协议，常见方法有<strong><em>GET、HEAD、PUT、POST、DELETE等</em></strong>。<br>请求头：包含了对客户端环境描述、请求信息等：请求方法、Host、User-Agent、Accept。<br>请求体：客户端发给服务端的具体数据<br>响应头：含了对服务器的描述和对返回数据的描述：http版本、状态码、Server、Content-Type、Date<br>响应体：服务器返回的具体数据<br>一个请求过程会做以下几件事</p>
<ol>
<li>DNS Lookup：域名解析，通过域名获取IP</li>
<li>TCP Handshake：通信过程由TCP来支持，完成传输层的功能；包含TCP的三次握手（client发送syn=j包到server，并进入SYN_SENT状态，等待server确认；server收到syn包，确认client的SYN ack = j+1,同时自己发送syn=k包，即SYN+ACK包，server进入SYN_RECV状态；client收到server的SYN+ACK包，想server发送确认包ACK ack=k+1,发送完毕后,client和server进入ESTABLISHEN状态，完成三次握手）</li>
<li>TLS/SSL Handshake：SSL是运行在TCP/IP层之上、应用层之下，为应用层提供加密数据通道；HTTPS比较消耗新能，主要体现在SSL握手消耗的时间上，</li>
<li>TCP/HTTP Request/Response<br><strong><em>可以从优化DNS解析和缓存、网络质量检测等方式来提升性能</em></strong><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3></li>
</ol>
<h3 id="数据安全与加密"><a href="#数据安全与加密" class="headerlink" title="数据安全与加密"></a>数据安全与加密</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h3 id="三方库"><a href="#三方库" class="headerlink" title="三方库"></a>三方库</h3><h3 id="cocoapods插件化开发"><a href="#cocoapods插件化开发" class="headerlink" title="cocoapods插件化开发"></a>cocoapods插件化开发</h3><h3 id="自动化打包与编译脚本开发"><a href="#自动化打包与编译脚本开发" class="headerlink" title="自动化打包与编译脚本开发"></a>自动化打包与编译脚本开发</h3><h3 id="跨平台了解"><a href="#跨平台了解" class="headerlink" title="跨平台了解"></a>跨平台了解</h3><h3 id="逆向开发"><a href="#逆向开发" class="headerlink" title="逆向开发"></a>逆向开发</h3>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a  href="/2019/04/20/iOS知识梳理/">iOS知识梳理</a></p>
        <p><span>文章作者:</span><a  href="/" title="访问 ZeusZhang 的个人博客">ZeusZhang</a></p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/04/20/iOS知识梳理/" title="iOS知识梳理">http://yoursite.com/2019/04/20/iOS知识梳理/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2019/04/20/iOS知识梳理/　　作者: ZeusZhang" title=""></span>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a  href="/2019/08/14/iOS二进制与cocoapods插件开发/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          iOS二进制与cocoapods插件开发
        
      </div>
    </a>
  
  
    <a  href="/2016/08/13/Category-NSInvocation通信方案/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Category+NSInvocation通信方案(CTMediator)</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>


  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存管理"><span class="toc-number">1.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引用计数"><span class="toc-number">1.1.</span> <span class="toc-text">引用计数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#引用计数的思考方"><span class="toc-number">1.1.1.</span> <span class="toc-text">引用计数的思考方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#autorelease"><span class="toc-number">1.1.2.</span> <span class="toc-text">autorelease</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARC"><span class="toc-number">1.2.</span> <span class="toc-text">ARC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#所有权修饰符"><span class="toc-number">1.2.1.</span> <span class="toc-text">所有权修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#内存管理规则总结"><span class="toc-number">1.2.2.</span> <span class="toc-text">内存管理规则总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#属性"><span class="toc-number">1.2.3.</span> <span class="toc-text">属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARC实现"><span class="toc-number">1.3.</span> <span class="toc-text">ARC实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#strong修饰符"><span class="toc-number">1.3.1.</span> <span class="toc-text">__strong修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#weak修饰符"><span class="toc-number">1.3.2.</span> <span class="toc-text">__weak修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#autoreleasing修饰符"><span class="toc-number">1.3.3.</span> <span class="toc-text">__autoreleasing修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blocks"><span class="toc-number">2.</span> <span class="toc-text">Blocks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Blocks结构体"><span class="toc-number">2.1.</span> <span class="toc-text">Blocks结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#截获自动变量"><span class="toc-number">2.2.</span> <span class="toc-text">截获自动变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block存储域"><span class="toc-number">2.3.</span> <span class="toc-text">Block存储域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block变量存储域"><span class="toc-number">2.4.</span> <span class="toc-text">__block变量存储域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#截获对象"><span class="toc-number">2.5.</span> <span class="toc-text">截获对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#block变量和对象"><span class="toc-number">2.6.</span> <span class="toc-text">__block变量和对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block循环引用"><span class="toc-number">2.7.</span> <span class="toc-text">Block循环引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委托代理"><span class="toc-number">3.</span> <span class="toc-text">委托代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代理"><span class="toc-number">3.1.</span> <span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#代理模式"><span class="toc-number">3.1.1.</span> <span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#weak修饰符-1"><span class="toc-number">3.1.2.</span> <span class="toc-text">weak修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#代理的使用"><span class="toc-number">3.1.3.</span> <span class="toc-text">代理的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#代理总结"><span class="toc-number">3.1.4.</span> <span class="toc-text">代理总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSProxy"><span class="toc-number">3.2.</span> <span class="toc-text">NSProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSProxy的组件化"><span class="toc-number">3.3.</span> <span class="toc-text">NSProxy的组件化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-number">4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GCD"><span class="toc-number">4.1.</span> <span class="toc-text">GCD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Dispatch-Queue-API"><span class="toc-number">4.1.1.</span> <span class="toc-text">Dispatch Queue API</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#种类"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">种类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-queue-create"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">dispatch_queue_create</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Main-Dispatch-Queue-Global-Dispatch-Queue"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Main Dispatch Queue/Global Dispatch Queue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-set-target-queue"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">dispatch_set_target_queue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-after"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">dispatch_after</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Dispatch-Group"><span class="toc-number">4.1.1.6.</span> <span class="toc-text">Dispatch Group</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-barrier-async"><span class="toc-number">4.1.1.7.</span> <span class="toc-text">dispatch_barrier_async</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#disaptch-sync"><span class="toc-number">4.1.1.8.</span> <span class="toc-text">disaptch_sync</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-apply"><span class="toc-number">4.1.1.9.</span> <span class="toc-text">dispatch_apply</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-suspend-dispatch-resume"><span class="toc-number">4.1.1.10.</span> <span class="toc-text">dispatch_suspend/dispatch_resume</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Dispatch-Semaphore"><span class="toc-number">4.1.1.11.</span> <span class="toc-text">Dispatch Semaphore</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#dispatch-once"><span class="toc-number">4.1.1.12.</span> <span class="toc-text">dispatch_once</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Dispatch-I-O"><span class="toc-number">4.1.1.13.</span> <span class="toc-text">Dispatch I/O</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSOperation"><span class="toc-number">4.2.</span> <span class="toc-text">NSOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Why-NSOperation？"><span class="toc-number">4.2.1.</span> <span class="toc-text">Why NSOperation？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#NSOperation操作和操作队列"><span class="toc-number">4.2.2.</span> <span class="toc-text">NSOperation操作和操作队列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NSThread"><span class="toc-number">4.3.</span> <span class="toc-text">NSThread</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#锁"><span class="toc-number">4.3.1.</span> <span class="toc-text">锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KVC-KVO"><span class="toc-number">5.</span> <span class="toc-text">KVC-KVO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#KVC"><span class="toc-number">5.1.</span> <span class="toc-text">KVC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#KVC底层原理"><span class="toc-number">5.1.1.</span> <span class="toc-text">KVC底层原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KVC运用场景"><span class="toc-number">5.1.2.</span> <span class="toc-text">KVC运用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#KVC异常处理"><span class="toc-number">5.1.3.</span> <span class="toc-text">KVC异常处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KVO"><span class="toc-number">5.2.</span> <span class="toc-text">KVO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#KVO底层原理"><span class="toc-number">5.2.1.</span> <span class="toc-text">KVO底层原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSRunloop"><span class="toc-number">6.</span> <span class="toc-text">NSRunloop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RunLoop与线程"><span class="toc-number">6.1.</span> <span class="toc-text">RunLoop与线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RunLoop对外接口"><span class="toc-number">6.2.</span> <span class="toc-text">RunLoop对外接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RunLoop的底层实现"><span class="toc-number">6.3.</span> <span class="toc-text">RunLoop的底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RunLoop的应用场景"><span class="toc-number">6.4.</span> <span class="toc-text">RunLoop的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AutoReleasePool"><span class="toc-number">6.4.1.</span> <span class="toc-text">AutoReleasePool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事件响应"><span class="toc-number">6.4.2.</span> <span class="toc-text">事件响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#手势识别"><span class="toc-number">6.4.3.</span> <span class="toc-text">手势识别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#界面更新"><span class="toc-number">6.4.4.</span> <span class="toc-text">界面更新</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定时器"><span class="toc-number">6.4.5.</span> <span class="toc-text">定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PerformSelecter"><span class="toc-number">6.4.6.</span> <span class="toc-text">PerformSelecter</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime"><span class="toc-number">7.</span> <span class="toc-text">Runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime数据结构分析"><span class="toc-number">7.1.</span> <span class="toc-text">Runtime数据结构分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime消息机制"><span class="toc-number">7.2.</span> <span class="toc-text">Runtime消息机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#消息转发"><span class="toc-number">7.3.</span> <span class="toc-text">消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态方法解析"><span class="toc-number">7.3.1.</span> <span class="toc-text">动态方法解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#后备接受者对象"><span class="toc-number">7.3.2.</span> <span class="toc-text">后备接受者对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#消息签名"><span class="toc-number">7.3.3.</span> <span class="toc-text">消息签名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runtime实际应用"><span class="toc-number">7.4.</span> <span class="toc-text">Runtime实际应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字典转模型"><span class="toc-number">7.4.1.</span> <span class="toc-text">字典转模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#路由中间件"><span class="toc-number">7.4.2.</span> <span class="toc-text">路由中间件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应链"><span class="toc-number">8.</span> <span class="toc-text">响应链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件的分发与传递"><span class="toc-number">8.1.</span> <span class="toc-text">事件的分发与传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找合适的响应对象"><span class="toc-number">8.2.</span> <span class="toc-text">寻找合适的响应对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#响应者链"><span class="toc-number">8.3.</span> <span class="toc-text">响应者链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout"><span class="toc-number">9.</span> <span class="toc-text">Layout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络"><span class="toc-number">10.</span> <span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP"><span class="toc-number">10.1.</span> <span class="toc-text">HTTP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能优化"><span class="toc-number">11.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据安全与加密"><span class="toc-number">12.</span> <span class="toc-text">数据安全与加密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">13.</span> <span class="toc-text">设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">14.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三方库"><span class="toc-number">15.</span> <span class="toc-text">三方库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cocoapods插件化开发"><span class="toc-number">16.</span> <span class="toc-text">cocoapods插件化开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动化打包与编译脚本开发"><span class="toc-number">17.</span> <span class="toc-text">自动化打包与编译脚本开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨平台了解"><span class="toc-number">18.</span> <span class="toc-text">跨平台了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逆向开发"><span class="toc-number">19.</span> <span class="toc-text">逆向开发</span></a></li></ol>
</div>
<style>
    .left-col .switch-btn {
        display: none;
    }
    .left-col .switch-area {
        display: none;
    }
</style>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";
    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
            $(".switch-btn, .switch-area").fadeOut(300);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
            $(".switch-btn, .switch-area").fadeIn(500);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
        $(".switch-btn, .switch-area").show();
    }
</script>




<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    
        <section class="changyan" id="comments">
  <!--<div id="uyan_frame"></div>-->
  <div id="SOHUCS"></div>
  <script charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/changyan.js"></script>
  <script type="text/javascript">
    window.changyan.api.config({
      appid: 'xxxx',
      conf: 'xxxxxxxxx'
    });
  </script>
</section>
    



    <div class="scroll" id="post-nav-button">
        
            <a  href="/2019/08/14/iOS二进制与cocoapods插件开发/" title="上一篇: iOS二进制与cocoapods插件开发">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a  href="/2016/08/13/Category-NSInvocation通信方案/" title="下一篇: Category+NSInvocation通信方案(CTMediator)">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/04/12/Flutter学习/">flutter学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/21/循环引用解决方案/">循环引用解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/14/iOS二进制与cocoapods插件开发/">iOS二进制与cocoapods插件开发</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/20/iOS知识梳理/">iOS知识梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/13/Category-NSInvocation通信方案/">Category+NSInvocation通信方案(CTMediator)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/08/Cocoapods静态库整理/">Cocoapods静态库整理</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/03/GCD使用总结/">GCD使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/21/iOS定时器整理对比/">iOS定时器整理对比</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/20/WKWebView与js的交互/">WKWebView与js交互</a></li></ul>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

    <script>
        $(".post-list").addClass("toc-article");
        // $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#toc, .switch-btn, .switch-area").toggle();
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
                $(".switch-btn, .switch-area").fadeToggle(300);
            }
        })
    </script>




    <script>
        
    </script>

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2020 ZeusZhang
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>


<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'xxxxx', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?xxxxxx";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>



<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>